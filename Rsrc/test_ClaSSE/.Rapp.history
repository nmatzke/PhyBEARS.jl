# DEC likelihoods#
trfn = "tree.newick"#
lnLs = NULL#
for (i in 1:length(new_fns))#
	{#
	max_range_size = 3#
	trfn = trfn#
	geogfn = new_fns[[i]]#
	BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
	BioGeoBEARS_run_object$trfn = trfn#
	BioGeoBEARS_run_object$geogfn = geogfn#
	BioGeoBEARS_run_object$max_range_size = max_range_size#
	BioGeoBEARS_run_object$min_branchlength = 0.000001#
	BioGeoBEARS_run_object$include_null_range = TRUE#
	BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
	BioGeoBEARS_run_object$return_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_ancprobs = TRUE#
	BioGeoBEARS_run_object$num_cores_to_use = 1#
	BioGeoBEARS_run_object$allow_null_tips = TRUE#
#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "est"] = 0.00001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "min"] = 0.000000001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "max"] = 1.00000001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "est"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "type"] = "fixed"#
	res = bears_optim_run(BioGeoBEARS_run_object, skip_optim=TRUE)#
	#res = bears_optim_run(BioGeoBEARS_run_object)#
	log(prod(res$computed_likelihoods_at_each_node))#
	res$total_loglikelihood#
	lnL = res#
	lnLs = c(lnLs, lnL)#
	}#
#
DEC_lnLs = lnLs#
DEC_lnLs
i
# DEC likelihoods#
trfn = "tree.newick"#
lnLs = NULL#
for (i in 1:length(new_fns))#
	{#
	max_range_size = 3#
	trfn = trfn#
	geogfn = new_fns[[i]]#
	BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
	BioGeoBEARS_run_object$trfn = trfn#
	BioGeoBEARS_run_object$geogfn = geogfn#
	BioGeoBEARS_run_object$max_range_size = max_range_size#
	BioGeoBEARS_run_object$min_branchlength = 0.000001#
	BioGeoBEARS_run_object$include_null_range = TRUE#
	BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
	BioGeoBEARS_run_object$return_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_ancprobs = TRUE#
	BioGeoBEARS_run_object$num_cores_to_use = 1#
	BioGeoBEARS_run_object$allow_null_tips = TRUE#
#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "est"] = 0.00001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "min"] = 0.000000001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "max"] = 1.00000001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "est"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "type"] = "fixed"#
	res = bears_optim_run(BioGeoBEARS_run_object, skip_optim=TRUE)#
	#res = bears_optim_run(BioGeoBEARS_run_object)#
	#log(prod(res$computed_likelihoods_at_each_node))#
	#res$total_loglikelihood#
	lnL = res#
	lnLs = c(lnLs, lnL)#
	}#
#
DEC_lnLs = lnLs#
DEC_lnLs
exp(DEC_lnLs)#
sum(exp(DEC_lnLs))
29.33189/64
round(exp(DEC_lnLs))
round(exp(DEC_lnLs),3)
cbind(new_fns, DEC_lnLs, exp(DEC_lnLs))
library(BioGeoBEARS)#
source("/drives/Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp.R")#
sourceall("/drives/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
calc_loglike_sp = compiler::cmpfun(calc_loglike_sp_prebyte)    # crucial to fix bug in uppass calculations#
calc_independent_likelihoods_on_each_branch = compiler::cmpfun(calc_independent_likelihoods_on_each_branch_prebyte)#
wd = "/drives/GDrive/__GDrive_projects/2017-06-20_27_Evolution2017_Portland/test/write_areas/"#
setwd(wd)#
#
# This is the example geography file for Hawaiian 2taxa#
# (from Ree & Smith 2008)#
geogfn = "geog_3areas.data"#
#
# Look at the raw geography text file:#
moref(geogfn)#
#
# Look at your geographic range data:#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
possible_ranges = c(#
"000",#
"100",#
"010",#
"001",#
"110",#
"011",#
"101",#
"111")#
#
new_fns = NULL#
for (i in 1:length(possible_ranges))#
	{#
	for (j in 1:length(possible_ranges))#
		{#
		sp1_range = possible_ranges[i]#
		sp2_range = possible_ranges[j]#
		tipranges_new = tipranges#
		tipranges_new@df[1,] = strsplit(sp1_range, split="")[[1]]#
		tipranges_new@df[2,] = strsplit(sp2_range, split="")[[1]]#
		new_fn = paste0("geog_", sp1_range, "_", sp2_range, ".data")#
		new_fns = c(new_fns, new_fn)#
		save_tipranges_to_LagrangePHYLIP(tipranges_object=tipranges_new, lgdata_fn=new_fn)#
		} # END for (j in 1:length(possible_ranges))#
	} # END for (i in 1:length(possible_ranges))#
# DEC likelihoods#
trfn = "tree.newick"#
lnLs = NULL#
for (i in 1:length(new_fns))#
	{#
	max_range_size = 3#
	trfn = trfn#
	geogfn = new_fns[[i]]#
	BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
	BioGeoBEARS_run_object$trfn = trfn#
	BioGeoBEARS_run_object$geogfn = geogfn#
	BioGeoBEARS_run_object$max_range_size = max_range_size#
	BioGeoBEARS_run_object$min_branchlength = 0.000001#
	BioGeoBEARS_run_object$include_null_range = TRUE#
	BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
	BioGeoBEARS_run_object$return_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_ancprobs = TRUE#
	BioGeoBEARS_run_object$num_cores_to_use = 1#
	BioGeoBEARS_run_object$allow_null_tips = TRUE#
#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "est"] = 0.00001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "min"] = 0.000000001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "max"] = 1.00000001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "est"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "type"] = "fixed"#
	res = bears_optim_run(BioGeoBEARS_run_object, skip_optim=TRUE)#
	#res = bears_optim_run(BioGeoBEARS_run_object)#
	#log(prod(res$computed_likelihoods_at_each_node))#
	#res$total_loglikelihood#
	lnL = res#
	lnLs = c(lnLs, lnL)#
	}
i'
i
geogfn
moref(geogfn)
geogfn = new_fns[[i]]#
	BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
	BioGeoBEARS_run_object$trfn = trfn#
	BioGeoBEARS_run_object$geogfn = geogfn#
	BioGeoBEARS_run_object$max_range_size = max_range_size#
	BioGeoBEARS_run_object$min_branchlength = 0.000001#
	BioGeoBEARS_run_object$include_null_range = TRUE#
	BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
	BioGeoBEARS_run_object$return_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_ancprobs = TRUE#
	BioGeoBEARS_run_object$num_cores_to_use = 1#
	BioGeoBEARS_run_object$allow_null_tips = TRUE#
#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "est"] = 0.00001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "min"] = 0.000000001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "max"] = 1.00000001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "est"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "type"] = "fixed"#
	res = bears_optim_run(BioGeoBEARS_run_object, skip_optim=TRUE)
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
	tipranges
tipranges_to_tip_condlikes_of_data_on_each_state(tipranges)
tipranges_to_tip_condlikes_of_data_on_each_state(tipranges, phy=tr)
tr = read.tree(trfn)#
	tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)
tipranges_to_tip_condlikes_of_data_on_each_state(tipranges, phy=tr)
library(BioGeoBEARS)#
source("/drives/Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp.R")#
sourceall("/drives/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
calc_loglike_sp = compiler::cmpfun(calc_loglike_sp_prebyte)    # crucial to fix bug in uppass calculations#
calc_independent_likelihoods_on_each_branch = compiler::cmpfun(calc_independent_likelihoods_on_each_branch_prebyte)
wd = "/drives/GDrive/__GDrive_projects/2017-06-20_27_Evolution2017_Portland/test/write_areas/"#
setwd(wd)#
#
# This is the example geography file for Hawaiian 2taxa#
# (from Ree & Smith 2008)#
geogfn = "geog_3areas.data"#
#
# Look at the raw geography text file:#
moref(geogfn)#
#
# Look at your geographic range data:#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
possible_ranges = c(#
"000",#
"100",#
"010",#
"001",#
"110",#
"011",#
"101",#
"111")#
#
new_fns = NULL#
for (i in 1:length(possible_ranges))#
	{#
	for (j in 1:length(possible_ranges))#
		{#
		sp1_range = possible_ranges[i]#
		sp2_range = possible_ranges[j]#
		tipranges_new = tipranges#
		tipranges_new@df[1,] = strsplit(sp1_range, split="")[[1]]#
		tipranges_new@df[2,] = strsplit(sp2_range, split="")[[1]]#
		new_fn = paste0("geog_", sp1_range, "_", sp2_range, ".data")#
		new_fns = c(new_fns, new_fn)#
		save_tipranges_to_LagrangePHYLIP(tipranges_object=tipranges_new, lgdata_fn=new_fn)#
		} # END for (j in 1:length(possible_ranges))#
	} # END for (i in 1:length(possible_ranges))
trfn = "tree.newick"#
lnLs = NULL#
for (i in 1:length(new_fns))#
	{#
	max_range_size = 3#
	trfn = trfn#
	geogfn = new_fns[[i]]#
	tr = read.tree(trfn)#
	tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
	tipranges#
	BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
	BioGeoBEARS_run_object$trfn = trfn#
	BioGeoBEARS_run_object$geogfn = geogfn#
	BioGeoBEARS_run_object$max_range_size = max_range_size#
	BioGeoBEARS_run_object$min_branchlength = 0.000001#
	BioGeoBEARS_run_object$include_null_range = TRUE#
	BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
	BioGeoBEARS_run_object$return_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_ancprobs = TRUE#
	BioGeoBEARS_run_object$num_cores_to_use = 1#
	BioGeoBEARS_run_object$allow_null_tips = TRUE#
#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "est"] = 0.00001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "min"] = 0.000000001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "max"] = 1.00000001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "est"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "type"] = "fixed"#
	res = bears_optim_run(BioGeoBEARS_run_object, skip_optim=TRUE)#
	#res = bears_optim_run(BioGeoBEARS_run_object)#
	#log(prod(res$computed_likelihoods_at_each_node))#
	#res$total_loglikelihood#
	lnL = res#
	lnLs = c(lnLs, lnL)#
	}
library(BioGeoBEARS)#
source("/drives/Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp.R")#
sourceall("/drives/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
calc_loglike_sp = compiler::cmpfun(calc_loglike_sp_prebyte)    # crucial to fix bug in uppass calculations#
calc_independent_likelihoods_on_each_branch = compiler::cmpfun(calc_independent_likelihoods_on_each_branch_prebyte)#
wd = "/drives/GDrive/__GDrive_projects/2017-06-20_27_Evolution2017_Portland/test/write_areas/"#
setwd(wd)#
#
# This is the example geography file for Hawaiian 2taxa#
# (from Ree & Smith 2008)#
geogfn = "geog_3areas.data"#
#
# Look at the raw geography text file:#
moref(geogfn)#
#
# Look at your geographic range data:#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
possible_ranges = c(#
"000",#
"100",#
"010",#
"001",#
"110",#
"011",#
"101",#
"111")#
#
new_fns = NULL#
for (i in 1:length(possible_ranges))#
	{#
	for (j in 1:length(possible_ranges))#
		{#
		sp1_range = possible_ranges[i]#
		sp2_range = possible_ranges[j]#
		tipranges_new = tipranges#
		tipranges_new@df[1,] = strsplit(sp1_range, split="")[[1]]#
		tipranges_new@df[2,] = strsplit(sp2_range, split="")[[1]]#
		new_fn = paste0("geog_", sp1_range, "_", sp2_range, ".data")#
		new_fns = c(new_fns, new_fn)#
		save_tipranges_to_LagrangePHYLIP(tipranges_object=tipranges_new, lgdata_fn=new_fn)#
		} # END for (j in 1:length(possible_ranges))#
	} # END for (i in 1:length(possible_ranges))
trfn = "tree.newick"#
lnLs = NULL
max_range_size = 3#
	trfn = trfn#
	geogfn = new_fns[[i]]#
	tr = read.tree(trfn)#
	tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
	tipranges#
	BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
	BioGeoBEARS_run_object$trfn = trfn#
	BioGeoBEARS_run_object$geogfn = geogfn#
	BioGeoBEARS_run_object$max_range_size = max_range_size#
	BioGeoBEARS_run_object$min_branchlength = 0.000001#
	BioGeoBEARS_run_object$include_null_range = TRUE#
	BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
	BioGeoBEARS_run_object$return_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_ancprobs = TRUE#
	BioGeoBEARS_run_object$num_cores_to_use = 1#
	BioGeoBEARS_run_object$allow_null_tips = TRUE#
#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "est"] = 0.00001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "min"] = 0.000000001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "max"] = 1.00000001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "est"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "type"] = "fixed"#
	res = bears_optim_run(BioGeoBEARS_run_object, skip_optim=TRUE)
trfn = "tree.newick"#
lnLs = NULL
library(BioGeoBEARS)#
source("/drives/Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp.R")#
sourceall("/drives/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
calc_loglike_sp = compiler::cmpfun(calc_loglike_sp_prebyte)    # crucial to fix bug in uppass calculations#
calc_independent_likelihoods_on_each_branch = compiler::cmpfun(calc_independent_likelihoods_on_each_branch_prebyte)#
wd = "/drives/GDrive/__GDrive_projects/2017-06-20_27_Evolution2017_Portland/test/write_areas/"#
setwd(wd)#
#
# This is the example geography file for Hawaiian 2taxa#
# (from Ree & Smith 2008)#
geogfn = "geog_3areas.data"#
#
# Look at the raw geography text file:#
moref(geogfn)#
#
# Look at your geographic range data:#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
possible_ranges = c(#
"000",#
"100",#
"010",#
"001",#
"110",#
"011",#
"101",#
"111")#
#
new_fns = NULL#
for (i in 1:length(possible_ranges))#
	{#
	for (j in 1:length(possible_ranges))#
		{#
		sp1_range = possible_ranges[i]#
		sp2_range = possible_ranges[j]#
		tipranges_new = tipranges#
		tipranges_new@df[1,] = strsplit(sp1_range, split="")[[1]]#
		tipranges_new@df[2,] = strsplit(sp2_range, split="")[[1]]#
		new_fn = paste0("geog_", sp1_range, "_", sp2_range, ".data")#
		new_fns = c(new_fns, new_fn)#
		save_tipranges_to_LagrangePHYLIP(tipranges_object=tipranges_new, lgdata_fn=new_fn)#
		} # END for (j in 1:length(possible_ranges))#
	} # END for (i in 1:length(possible_ranges))
max_range_size = 3#
	trfn = trfn#
	geogfn = new_fns[[i]]#
	tr = read.tree(trfn)#
	tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
	tipranges#
	BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
	BioGeoBEARS_run_object$trfn = trfn#
	BioGeoBEARS_run_object$geogfn = geogfn#
	BioGeoBEARS_run_object$max_range_size = max_range_size#
	BioGeoBEARS_run_object$min_branchlength = 0.000001#
	BioGeoBEARS_run_object$include_null_range = TRUE#
	BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
	BioGeoBEARS_run_object$return_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_ancprobs = TRUE#
	BioGeoBEARS_run_object$num_cores_to_use = 1#
	BioGeoBEARS_run_object$allow_null_tips = TRUE#
#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "est"] = 0.00001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "min"] = 0.000000001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "max"] = 1.00000001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "est"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "type"] = "fixed"#
	res = bears_optim_run(BioGeoBEARS_run_object, skip_optim=TRUE)
trfn = "tree.newick"#
lnLs = NULL#
for (i in 1:length(new_fns))#
	{#
	max_range_size = 3#
	trfn = trfn#
	geogfn = new_fns[[i]]#
	tr = read.tree(trfn)#
	tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
	tipranges#
	BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
	BioGeoBEARS_run_object$trfn = trfn#
	BioGeoBEARS_run_object$geogfn = geogfn#
	BioGeoBEARS_run_object$max_range_size = max_range_size#
	BioGeoBEARS_run_object$min_branchlength = 0.000001#
	BioGeoBEARS_run_object$include_null_range = TRUE#
	BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
	BioGeoBEARS_run_object$return_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_ancprobs = TRUE#
	BioGeoBEARS_run_object$num_cores_to_use = 1#
	BioGeoBEARS_run_object$allow_null_tips = TRUE#
#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "est"] = 0.00001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "min"] = 0.000000001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "max"] = 1.00000001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "est"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "type"] = "fixed"#
	res = bears_optim_run(BioGeoBEARS_run_object, skip_optim=TRUE)#
	#res = bears_optim_run(BioGeoBEARS_run_object)#
	#log(prod(res$computed_likelihoods_at_each_node))#
	#res$total_loglikelihood#
	lnL = res#
	lnLs = c(lnLs, lnL)#
	}
DEC_lnLs = lnLs#
DEC_lnLs#
exp(DEC_lnLs)#
#
cbind(new_fns, DEC_lnLs, exp(DEC_lnLs))
sum(exp(DEC_lnLs))
exp(DEC_lnLs)
round(exp(DEC_lnLs),3)
tab = cbind(new_fns, round(DEC_lnLs,4), round(exp(DEC_lnLs),3))#
tab = dfnums_to_numeric(tab)#
tab
tab = cbind(new_fns, round(DEC_lnLs,4), round(exp(DEC_lnLs),3))#
tab = as.data.frame(tab)#
tab = dfnums_to_numeric(tab)#
tab
sum(exp(DEC_lnLs))
1/0.83
1/0.083
# DEC+J likelihoods#
trfn = "tree.newick"#
lnLs = NULL#
for (i in 1:length(new_fns))#
	{#
	max_range_size = 3#
	trfn = trfn#
	geogfn = new_fns[[i]]#
	BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
	BioGeoBEARS_run_object$trfn = trfn#
	BioGeoBEARS_run_object$geogfn = geogfn#
	BioGeoBEARS_run_object$max_range_size = max_range_size#
	BioGeoBEARS_run_object$min_branchlength = 0.000001#
	BioGeoBEARS_run_object$include_null_range = TRUE#
	BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
	BioGeoBEARS_run_object$return_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_ancprobs = TRUE#
	BioGeoBEARS_run_object$num_cores_to_use = 1#
	BioGeoBEARS_run_object$allow_null_tips = TRUE#
#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "est"] = 0.00001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "min"] = 0.000000001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "max"] = 1.00000001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "est"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "type"] = "fixed"#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j", "init"] = 0.1#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j", "est"] = 0.1#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j", "type"] = "fixed"#
	res = bears_optim_run(BioGeoBEARS_run_object, skip_optim=TRUE)#
	#res = bears_optim_run(BioGeoBEARS_run_object)#
	#log(prod(res$computed_likelihoods_at_each_node))#
	#res$total_loglikelihood#
	lnL = res#
	lnLs = c(lnLs, lnL)#
	}#
#
DECj_lnLs = lnLs#
exp(DECj_lnLs)#
#
tab_DECj = cbind(new_fns, round(DECj_lnLs,4), round(exp(DECj_lnLs),3))#
tab_DECj = as.data.frame(tab_DECj)#
tab_DECj = dfnums_to_numeric(tab_DECj)#
tab_DECj
sum(exp(DECj_lnLs))
tab[,3]
tab[,3]==0
sum(tab[,3]==0)
21/64
tab[,3] * 0.25
sum(tab[,3] * 0.25)
sum(tab[,3])* 0.25
sum(tab_DECj[,3])* 0.25
1/0.167
tab
moref(geog_011_110.data)
moref("geog_011_110.data")
i=38#
	max_range_size = 3#
	trfn = trfn#
	geogfn = new_fns[[i]]#
	tr = read.tree(trfn)#
	tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
	tipranges#
	BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
	BioGeoBEARS_run_object$trfn = trfn#
	BioGeoBEARS_run_object$geogfn = geogfn#
	BioGeoBEARS_run_object$max_range_size = max_range_size#
	BioGeoBEARS_run_object$min_branchlength = 0.000001#
	BioGeoBEARS_run_object$include_null_range = TRUE#
	BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
	BioGeoBEARS_run_object$return_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_ancprobs = TRUE#
	BioGeoBEARS_run_object$num_cores_to_use = 1#
	BioGeoBEARS_run_object$allow_null_tips = TRUE#
#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "est"] = 0.00001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "min"] = 0.000000001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "max"] = 1.00000001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "est"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "type"] = "fixed"#
	res = bears_optim_run(BioGeoBEARS_run_object, skip_optim=TRUE)#
	#res = bears_optim_run(BioGeoBEARS_run_object)#
	#log(prod(res$computed_likelihoods_at_each_node))#
	#res$total_loglikelihood#
	lnL = res
res
res = bears_optim_run(BioGeoBEARS_run_object)
res
names(res)
res$ML_marginal_prob_each_state_at_branch_top_AT_node
round(res$ML_marginal_prob_each_state_at_branch_top_AT_node,3)
round(res$ML_marginal_prob_each_state_at_branch_bottom_below_node,3)
round(res$computed_likelihoods_at_each_node,3)
geogfn
moref(geogfn)
res$condlikes_of_each_state
i=38#
	max_range_size = 3#
	trfn = trfn#
	geogfn = new_fns[[i]]#
	tr = read.tree(trfn)#
	tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
	tipranges
i=38#
	max_range_size = 3#
	trfn = trfn#
	geogfn = new_fns[[i]]#
	tr = read.tree(trfn)#
	tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
	tipranges#
	BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
	BioGeoBEARS_run_object$trfn = trfn#
	BioGeoBEARS_run_object$geogfn = geogfn#
	BioGeoBEARS_run_object$max_range_size = max_range_size#
	BioGeoBEARS_run_object$min_branchlength = 0.000001#
	BioGeoBEARS_run_object$include_null_range = TRUE#
	BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
	BioGeoBEARS_run_object$return_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_ancprobs = TRUE#
	BioGeoBEARS_run_object$num_cores_to_use = 1#
	BioGeoBEARS_run_object$allow_null_tips = FALSE#
#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "est"] = 0.00001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "min"] = 0.000000001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "max"] = 1.00000001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "est"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "type"] = "fixed"#
	#res = bears_optim_run(BioGeoBEARS_run_object, skip_optim=TRUE)#
	res = bears_optim_run(BioGeoBEARS_run_object)
res
res$condlikes_of_each_state
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)
names(BioGeoBEARS_run_object)
BioGeoBEARS_run_object$max_range_size
geogfn
tipranges
moref(geogfn)
tr = read.tree(trfn)#
	tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
	tipranges
tipranges_to_tip_condlikes_of_data_on_each_state(tipranges=tipranges, phy=tr, states_list=NULL, maxareas=length(getareas_from_tipranges_object(tipranges)), include_null_range=TRUE, useAmbiguities=FALSE, trait_as_tip_condlikes=NULL, allow_null_tips=FALSE)
length(getareas_from_tipranges_object(tipranges))
tipranges
tipranges=tipranges;#
 phy=tr;#
 states_list=NULL;#
 maxareas=length(getareas_from_tipranges_object(tipranges));#
 include_null_range=TRUE;#
 useAmbiguities=FALSE;#
 trait_as_tip_condlikes=NULL;#
 allow_null_tips=FALSE
areanames = getareas_from_tipranges_object(tipranges)#
	areas_list_0based = seq(0, (length(areanames)-1), 1)#
	#print(areanames)#
	#print("stop here")#
	if (is.null(states_list))#
		{#
		cat("Note: tipranges_to_tip_condlikes_of_data_on_each_state() is\n")#
		cat("      creating 'states_list' automatically.\n")#
		states_list = areas_list_to_states_list_new(areas=areas_list_0based, include_null_range=include_null_range, maxareas=maxareas)#
		}#
	# Check for ranges greater than the maximum number of areas in states_list#
	ranges_greater_than_maxareas_TF = sapply(states_list, length) > maxareas#
	# Reduce states_list accordingly, if any are found#
	if (sum(ranges_greater_than_maxareas_TF) > 0)#
		{#
		states_list = states_list[ranges_greater_than_maxareas_TF == FALSE]#
		}
states_list
((useAmbiguities == FALSE) || (sum(tipranges@df == "?") == 0))
# Get the letter code ranges for each binary state#
		tipranges@df[tipranges@df == "?"] = 0#
		letter_code_ranges = binary_ranges_to_letter_codes(tipranges=tipranges, areanames=areanames)#
		number_code_ranges_0based = binary_ranges_to_letter_codes(tipranges=tipranges, areanames=areas_list_0based)#
		#print(letter_code_ranges)#
		names(letter_code_ranges) = NULL#
		letter_code_ranges
tip_condlikes_of_data_on_each_state = matrix(data=0, nrow=length(phy$tip.label), ncol=length(states_list))
tip_condlikes_of_data_on_each_state
tipranges_df_order = match(phy$tip.label, rownames(tipranges@df))#
		letter_code_ranges = letter_code_ranges[tipranges_df_order]#
		number_code_ranges_0based = number_code_ranges_0based[tipranges_df_order]
number_code_ranges_0based
tipranges_df_order = match(phy$tip.label, rownames(tipranges@df))
letter_code_ranges = letter_code_ranges[tipranges_df_order]
letter_code_ranges
number_code_ranges_0based = number_code_ranges_0based[tipranges_df_order]
number_code_ranges_0based
allowed_states_list_0based_txt = sapply(X=states_list, FUN=paste, collapse="_", sep="")
allowed_states_list_0based_txt
i=1
rownum=1
temp_state_txt = paste(letter_code_ranges[rownum][[1]], collapse="_", sep="")#
			temp_state = paste(number_code_ranges_0based[rownum][[1]], collapse="_", sep="")
temp_state
temp_state_txt
letter_code_ranges
letter_code_ranges[rownum]
letter_code_ranges
tipranges_df_order
number_code_ranges_0based
number_code_ranges_0based[rownum][[1]]
letter_code_ranges[rownum]
number_code_ranges_0based[rownum]
number_code_ranges_0based[rownum][[1]]
letter_code_ranges
number_code_ranges_0based
# See if this tipstate matches anything in the list#
			state_match_TF = temp_state == allowed_states_list_0based_txt
state_match_TF
binary_ranges_to_letter_codes(tipranges=tipranges, areanames=areas_list_0based)
tipranges
binary_ranges_to_letter_codes(tipranges=tipranges, areanames=areanames)
areanames
letter_code_ranges = binary_ranges_to_letter_codes(tipranges=tipranges, areanames=areanames)#
		number_code_ranges_0based = binary_ranges_to_letter_codes(tipranges=tipranges, areanames=areas_list_0based)
number_code_ranges_0based
names(letter_code_ranges) = NULL#
		letter_code_ranges
tip_condlikes_of_data_on_each_state = matrix(data=0, nrow=length(phy$tip.label), ncol=length(states_list))
letter_code_ranges
letter_code_ranges[tipranges_df_order]
rownames(tipranges@df)
tipranges_df_order = match(phy$tip.label, rownames(tipranges@df))#
		letter_code_ranges = letter_code_ranges[,tipranges_df_order]
letter_code_ranges
letter_code_ranges = letter_code_ranges[,tipranges_df_order]#
		number_code_ranges_0based = number_code_ranges_0based[tipranges_df_order]
number_code_ranges_0based
# Get the letter code ranges for each binary state#
		tipranges@df[tipranges@df == "?"] = 0#
		letter_code_ranges = binary_ranges_to_letter_codes(tipranges=tipranges, areanames=areanames)#
		number_code_ranges_0based = binary_ranges_to_letter_codes(tipranges=tipranges, areanames=areas_list_0based)#
		#print(letter_code_ranges)#
		names(letter_code_ranges) = NULL#
		letter_code_ranges#
		# Empty matrix of tip relative likelihoods#
		tip_condlikes_of_data_on_each_state = matrix(data=0, nrow=length(phy$tip.label), ncol=length(states_list))#
#
		# Make sure the letter code ranges and number code ranges are in the same order as the #
		# phylogeny tips#
		tipranges_df_order = match(phy$tip.label, rownames(tipranges@df))#
		# Possible bug?? 2017-06-23 NJM#
		letter_code_ranges = letter_code_ranges[,tipranges_df_order]#
		number_code_ranges_0based = number_code_ranges_0based[,tipranges_df_order]
letter_code_ranges
number_code_ranges_0based
letter_code_ranges = letter_code_ranges[,tipranges_df_order]#
		number_code_ranges_0based = number_code_ranges_0based[,tipranges_df_order]#
		# Collapse the states to text fields and compare#
		allowed_states_list_0based_txt = sapply(X=states_list, FUN=paste, collapse="_", sep="")
allowed_states_list_0based_txt
source('/drives/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_basics_v1.R', chdir = TRUE)
tip_condlikes = tipranges_to_tip_condlikes_of_data_on_each_state(tipranges=tipranges, phy=tr, states_list=NULL, maxareas=length(getareas_from_tipranges_object(tipranges)), include_null_range=TRUE, useAmbiguities=FALSE, trait_as_tip_condlikes=NULL, allow_null_tips=FALSE)
tip_condlikes
# Get the letter code ranges for each binary state#
		tipranges@df[tipranges@df == "?"] = 0#
		letter_code_ranges = binary_ranges_to_letter_codes(tipranges=tipranges, areanames=areanames)#
		number_code_ranges_0based = binary_ranges_to_letter_codes(tipranges=tipranges, areanames=areas_list_0based)#
		#print(letter_code_ranges)#
		names(letter_code_ranges) = NULL#
		letter_code_ranges#
		# Empty matrix of tip relative likelihoods#
		tip_condlikes_of_data_on_each_state = matrix(data=0, nrow=length(phy$tip.label), ncol=length(states_list))#
#
		# Make sure the letter code ranges and number code ranges are in the same order as the #
		# phylogeny tips#
		tipranges_df_order = match(phy$tip.label, rownames(tipranges@df))#
		# Possible bug?? 2017-06-23 NJM -- left out [, somehow#
		letter_code_ranges = letter_code_ranges[,tipranges_df_order]#
		number_code_ranges_0based = number_code_ranges_0based[,tipranges_df_order]#
		# Collapse the states to text fields and compare#
		allowed_states_list_0based_txt = sapply(X=states_list, FUN=paste, collapse="_", sep="")#
		#print(allowed_states_list_0based_txt)#
		#print(allowed_states_list_0based_txt)
tipranges
temp_state_txt = paste(letter_code_ranges[rownum][[1]], collapse="_", sep="")#
			temp_state = paste(number_code_ranges_0based[rownum][[1]], collapse="_", sep="")#
			# Check null range for test#
			changeflag = FALSE
temp_state_txt
number_code_ranges_0based
letter_code_ranges[rownum]
letter_code_ranges[,rownum]
letter_code_ranges[,rownum][[1]]
letter_code_ranges = apply(X=tipranges@df, MARGIN=1, FUN=binary_range_to_letter_code_list, areanames=areanames)
letter_code_ranges
binary_range_to_letter_code_list
tipranges@df
tipranges@df[1,]=c(1,1,1)
tipranges@df
apply(X=tipranges@df, MARGIN=1, FUN=binary_range_to_letter_code_list, areanames=areanames)
?apply
binary_range_to_letter_code_list
binary_range_to_letter_code_list <- function(tipranges_row, areanames)#
	{#
	present_TF = tipranges_row == 1#
	list_of_areas_in_the_state = as.list(c(areanames[present_TF]))#
	return(list_of_areas_in_the_state)#
	}
apply(X=tipranges@df, MARGIN=1, FUN=binary_range_to_letter_code_list, areanames=areanames)
x=apply(X=tipranges@df, MARGIN=1, FUN=binary_range_to_letter_code_list, areanames=areanames)
length(x)
x[1]
binary_range_to_letter_code_list <- function(tipranges_row, areanames)#
	{#
	present_TF = tipranges_row == 1#
	list_of_areas_in_the_state = list(c(areanames[present_TF]))#
	return(list_of_areas_in_the_state)#
	}
x=apply(X=tipranges@df, MARGIN=1, FUN=binary_range_to_letter_code_list, areanames=areanames)
x
length(x)
x[[1]]
x[[1]][1]
is.matrix(list_of_areas_in_the_state)
present_TF = tipranges_row == 1#
	list_of_areas_in_the_state = c(areanames[present_TF])
tipranges@df[1,]=c(1,1,0)
binary_range_to_letter_code_list <- function(tipranges_row, areanames)#
	{#
	present_TF = tipranges_row == 1#
	list_of_areas_in_the_state = c(areanames[present_TF])#
	return(list_of_areas_in_the_state)#
	}
apply(X=tipranges@df, MARGIN=1, FUN=binary_range_to_letter_code_list, areanames=areanames)
lapply(X=tipranges@df, MARGIN=1, FUN=binary_range_to_letter_code_list, areanames=areanames)
as.list(apply(X=tipranges@df, MARGIN=1, FUN=binary_range_to_letter_code_list, areanames=areanames))
list(10
)
as.list(letter_code_ranges)
lapply(seq_len(ncol(letter_code_ranges)), function(i) x[,i])
letter_code_ranges
lapply(seq_len(ncol(letter_code_ranges)), function(i) letter_code_ranges[,i])
source('/drives/Dropbox/_njm/__packages/BioGeoBEARS_setup/BioGeoBEARS_basics_v1.R', chdir = TRUE)
tip_condlikes = tipranges_to_tip_condlikes_of_data_on_each_state(tipranges=tipranges, phy=tr, states_list=NULL, maxareas=length(getareas_from_tipranges_object(tipranges)), include_null_range=TRUE, useAmbiguities=FALSE, trait_as_tip_condlikes=NULL, allow_null_tips=FALSE)
tip_condlikes
library(BioGeoBEARS)#
source("/drives/Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp.R")#
sourceall("/drives/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
calc_loglike_sp = compiler::cmpfun(calc_loglike_sp_prebyte)    # crucial to fix bug in uppass calculations#
calc_independent_likelihoods_on_each_branch = compiler::cmpfun(calc_independent_likelihoods_on_each_branch_prebyte)#
wd = "/drives/GDrive/__GDrive_projects/2017-06-20_27_Evolution2017_Portland/test/write_areas/"#
setwd(wd)#
#
# This is the example geography file for Hawaiian 2taxa#
# (from Ree & Smith 2008)#
geogfn = "geog_3areas.data"#
#
# Look at the raw geography text file:#
moref(geogfn)#
#
# Look at your geographic range data:#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
possible_ranges = c(#
"000",#
"100",#
"010",#
"001",#
"110",#
"011",#
"101",#
"111")
new_fns = NULL#
for (i in 1:length(possible_ranges))#
	{#
	for (j in 1:length(possible_ranges))#
		{#
		sp1_range = possible_ranges[i]#
		sp2_range = possible_ranges[j]#
		tipranges_new = tipranges#
		tipranges_new@df[1,] = strsplit(sp1_range, split="")[[1]]#
		tipranges_new@df[2,] = strsplit(sp2_range, split="")[[1]]#
		new_fn = paste0("geog_", sp1_range, "_", sp2_range, ".data")#
		new_fns = c(new_fns, new_fn)#
		save_tipranges_to_LagrangePHYLIP(tipranges_object=tipranges_new, lgdata_fn=new_fn)#
		} # END for (j in 1:length(possible_ranges))#
	} # END for (i in 1:length(possible_ranges))
trfn = "tree.newick"#
lnLs = NULL#
for (i in 1:length(new_fns))#
	{#
	#i=38#
	max_range_size = 3#
	trfn = trfn#
	geogfn = new_fns[[i]]#
	tr = read.tree(trfn)#
	tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
	tipranges#
# tip_condlikes = tipranges_to_tip_condlikes_of_data_on_each_state(tipranges=tipranges, phy=tr, states_list=NULL, maxareas=length(getareas_from_tipranges_object(tipranges)), include_null_range=TRUE, useAmbiguities=FALSE, trait_as_tip_condlikes=NULL, allow_null_tips=FALSE)#
# #
# #
# tipranges=tipranges;#
#  phy=tr;#
#  states_list=NULL;#
#  maxareas=length(getareas_from_tipranges_object(tipranges));#
#  include_null_range=TRUE;#
#  useAmbiguities=FALSE;#
#  trait_as_tip_condlikes=NULL;#
#  allow_null_tips=FALSE#
# #
	BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
	BioGeoBEARS_run_object$trfn = trfn#
	BioGeoBEARS_run_object$geogfn = geogfn#
	BioGeoBEARS_run_object$max_range_size = max_range_size#
	BioGeoBEARS_run_object$min_branchlength = 0.000001#
	BioGeoBEARS_run_object$include_null_range = TRUE#
	BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
	BioGeoBEARS_run_object$return_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_ancprobs = TRUE#
	BioGeoBEARS_run_object$num_cores_to_use = 1#
	BioGeoBEARS_run_object$allow_null_tips = FALSE#
#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "est"] = 0.00001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "min"] = 0.000000001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "max"] = 1.00000001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "est"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "type"] = "fixed"#
	#res = bears_optim_run(BioGeoBEARS_run_object, skip_optim=TRUE)#
	res = bears_optim_run(BioGeoBEARS_run_object)#
	#log(prod(res$computed_likelihoods_at_each_node))#
	#res$total_loglikelihood#
	lnL = res#
	lnLs = c(lnLs, lnL)#
	}#
#
DEC_lnLs = lnLs#
DEC_lnLs#
exp(DEC_lnLs)
trfn = "tree.newick"#
lnLs = NULL#
for (i in 1:length(new_fns))#
	{#
	#i=38#
	max_range_size = 3#
	trfn = trfn#
	geogfn = new_fns[[i]]#
	tr = read.tree(trfn)#
	tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
	tipranges#
# tip_condlikes = tipranges_to_tip_condlikes_of_data_on_each_state(tipranges=tipranges, phy=tr, states_list=NULL, maxareas=length(getareas_from_tipranges_object(tipranges)), include_null_range=TRUE, useAmbiguities=FALSE, trait_as_tip_condlikes=NULL, allow_null_tips=FALSE)#
# #
# #
# tipranges=tipranges;#
#  phy=tr;#
#  states_list=NULL;#
#  maxareas=length(getareas_from_tipranges_object(tipranges));#
#  include_null_range=TRUE;#
#  useAmbiguities=FALSE;#
#  trait_as_tip_condlikes=NULL;#
#  allow_null_tips=FALSE#
# #
	BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
	BioGeoBEARS_run_object$trfn = trfn#
	BioGeoBEARS_run_object$geogfn = geogfn#
	BioGeoBEARS_run_object$max_range_size = max_range_size#
	BioGeoBEARS_run_object$min_branchlength = 0.000001#
	BioGeoBEARS_run_object$include_null_range = TRUE#
	BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
	BioGeoBEARS_run_object$return_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_ancprobs = TRUE#
	BioGeoBEARS_run_object$num_cores_to_use = 1#
	BioGeoBEARS_run_object$allow_null_tips = TRUE#
#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "est"] = 0.00001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "min"] = 0.000000001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "max"] = 1.00000001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "est"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "type"] = "fixed"#
	#res = bears_optim_run(BioGeoBEARS_run_object, skip_optim=TRUE)#
	res = bears_optim_run(BioGeoBEARS_run_object)#
	#log(prod(res$computed_likelihoods_at_each_node))#
	#res$total_loglikelihood#
	lnL = res#
	lnLs = c(lnLs, lnL)#
	}
# DEC likelihoods#
trfn = "tree.newick"#
lnLs = NULL#
for (i in 1:length(new_fns))#
	{#
	#i=38#
	max_range_size = 3#
	trfn = trfn#
	geogfn = new_fns[[i]]#
	tr = read.tree(trfn)#
	tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
	tipranges#
# tip_condlikes = tipranges_to_tip_condlikes_of_data_on_each_state(tipranges=tipranges, phy=tr, states_list=NULL, maxareas=length(getareas_from_tipranges_object(tipranges)), include_null_range=TRUE, useAmbiguities=FALSE, trait_as_tip_condlikes=NULL, allow_null_tips=FALSE)#
# #
# #
# tipranges=tipranges;#
#  phy=tr;#
#  states_list=NULL;#
#  maxareas=length(getareas_from_tipranges_object(tipranges));#
#  include_null_range=TRUE;#
#  useAmbiguities=FALSE;#
#  trait_as_tip_condlikes=NULL;#
#  allow_null_tips=FALSE#
# #
	BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
	BioGeoBEARS_run_object$trfn = trfn#
	BioGeoBEARS_run_object$geogfn = geogfn#
	BioGeoBEARS_run_object$max_range_size = max_range_size#
	BioGeoBEARS_run_object$min_branchlength = 0.000001#
	BioGeoBEARS_run_object$include_null_range = TRUE#
	BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
	BioGeoBEARS_run_object$return_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_ancprobs = TRUE#
	BioGeoBEARS_run_object$num_cores_to_use = 1#
	BioGeoBEARS_run_object$allow_null_tips = TRUE#
#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "est"] = 0.00001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "min"] = 0.000000001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "max"] = 1.00000001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "est"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "type"] = "fixed"#
	res = bears_optim_run(BioGeoBEARS_run_object, skip_optim=TRUE)#
	#res = bears_optim_run(BioGeoBEARS_run_object)#
	#log(prod(res$computed_likelihoods_at_each_node))#
	#res$total_loglikelihood#
	lnL = res#
	lnLs = c(lnLs, lnL)#
	}#
#
DEC_lnLs = lnLs#
DEC_lnLs#
exp(DEC_lnLs)
tab_DEC = cbind(new_fns, round(DEC_lnLs,4), round(exp(DEC_lnLs),3))#
tab_DEC = as.data.frame(tab_DEC)#
tab_DEC = dfnums_to_numeric(tab_DEC)#
tab_DEC
DEC_lnLs = lnLs#
DEC_lnLs#
exp(DEC_lnLs)#
#
tab_DEC = cbind(new_fns, round(DEC_lnLs,4), round(exp(DEC_lnLs),3))#
tab_DEC = as.data.frame(tab_DEC)#
tab_DEC = dfnums_to_numeric(tab_DEC)#
tab_DEC
sum(exp(DEC_lnLs))
# DEC+J likelihoods#
trfn = "tree.newick"#
lnLs = NULL#
for (i in 1:length(new_fns))#
	{#
	max_range_size = 3#
	trfn = trfn#
	geogfn = new_fns[[i]]#
	BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
	BioGeoBEARS_run_object$trfn = trfn#
	BioGeoBEARS_run_object$geogfn = geogfn#
	BioGeoBEARS_run_object$max_range_size = max_range_size#
	BioGeoBEARS_run_object$min_branchlength = 0.000001#
	BioGeoBEARS_run_object$include_null_range = TRUE#
	BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
	BioGeoBEARS_run_object$return_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_ancprobs = TRUE#
	BioGeoBEARS_run_object$num_cores_to_use = 1#
	BioGeoBEARS_run_object$allow_null_tips = TRUE#
#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "est"] = 0.00001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "min"] = 0.000000001#
	#BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "max"] = 1.00000001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "est"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "type"] = "fixed"#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j", "init"] = 0.1#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j", "est"] = 0.1#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j", "type"] = "fixed"#
	res = bears_optim_run(BioGeoBEARS_run_object, skip_optim=TRUE)#
	#res = bears_optim_run(BioGeoBEARS_run_object)#
	#log(prod(res$computed_likelihoods_at_each_node))#
	#res$total_loglikelihood#
	lnL = res#
	lnLs = c(lnLs, lnL)#
	}#
#
DECj_lnLs = lnLs#
exp(DECj_lnLs)#
#
tab_DECj = cbind(new_fns, round(DECj_lnLs,4), round(exp(DECj_lnLs),3))#
tab_DECj = as.data.frame(tab_DECj)#
tab_DECj = dfnums_to_numeric(tab_DECj)#
tab_DECj
sum(exp(DECj_lnLs))
plot(DEC_lnLs, DECj_lnLs)
wd = np("~")#
setwd(wd)#
#
# Double-check your working directory with getwd()#
getwd()#
#
########################################################
# SETUP: Extension data directory#
########################################################
# When R packages contain extra files, they are stored in the "extdata" directory #
# inside the installed package.#
##
# BioGeoBEARS contains various example files and scripts in its extdata directory.#
# #
# Each computer operating system might install BioGeoBEARS in a different place, #
# depending on your OS and settings. #
# #
# However, you can find the extdata directory like this:#
extdata_dir = np(system.file("extdata", package="BioGeoBEARS"))#
extdata_dir#
list.files(extdata_dir)#
#
# "system.file" looks in the directory of a specified package (in this case BioGeoBEARS)#
# The function "np" is just a shortcut for normalizePath(), which converts the #
# path to the format appropriate for your system (e.g., Mac/Linux use "/", but #
# Windows uses "\\", if memory serves).#
#
# Even when using your own data files, you should KEEP these commands in your #
# script, since the plot_BioGeoBEARS_results function needs a script from the #
# extdata directory to calculate the positions of "corners" on the plot. This cannot#
# be made into a straight up BioGeoBEARS function because it uses C routines #
# from the package APE which do not pass R CMD check for some reason.#
#
########################################################
# SETUP: YOUR TREE FILE AND GEOGRAPHY FILE#
########################################################
# Example files are given below. To run your own data,#
# make the below lines point to your own files, e.g.#
# trfn = "/mydata/frogs/frogBGB/tree.newick"#
# geogfn = "/mydata/frogs/frogBGB/geog.data"#
#
########################################################
# Phylogeny file#
# Notes: #
# 1. Must be binary/bifurcating: no polytomies#
# 2. No negative branchlengths (e.g. BEAST MCC consensus trees sometimes have negative branchlengths)#
# 3. Be careful of very short branches, as BioGeoBEARS will interpret ultrashort branches as direct ancestors#
# 4. You can use non-ultrametric trees, but BioGeoBEARS will interpret any tips significantly below the #
#    top of the tree as fossils!  This is only a good idea if you actually do have fossils in your tree,#
#    as in e.g. Wood, Matzke et al. (2013), Systematic Biology.#
# 5. The default settings of BioGeoBEARS make sense for trees where the branchlengths are in units of #
#    millions of years, and the tree is 1-1000 units tall. If you have a tree with a total height of#
#    e.g. 0.00001, you will need to adjust e.g. the max values of d and e, or (simpler) multiply all#
#    your branchlengths to get them into reasonable units.#
# 6. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
########################################################
# This is the example Newick file for Hawaiian Psychotria#
# (from Ree & Smith 2008)#
# "trfn" = "tree file name"#
trfn = np(paste(addslash(extdata_dir), "Psychotria_5.2.newick", sep=""))#
#
# Look at the raw Newick file:#
moref(trfn)#
#
# Look at your phylogeny:#
tr = read.tree(trfn)#
tr#
plot(tr)#
title("Example Psychotria phylogeny from Ree & Smith (2008)")#
axisPhylo() # plots timescale#
#
########################################################
# Geography file#
# Notes:#
# 1. This is a PHYLIP-formatted file. This means that in the #
#    first line, #
#    - the 1st number equals the number of rows (species)#
#    - the 2nd number equals the number of columns (number of areas)#
#    - after a tab, put the areas in parentheses, with spaces: (A B C D)#
##
# 1.5. Example first line:#
#    10    4    (A B C D)#
# #
# 2. The second line, and subsequent lines:#
#    speciesA    0110#
#    speciesB    0111#
#    speciesC    0001#
#         ...#
# #
# 2.5a. This means a TAB between the species name and the area 0/1s#
# 2.5b. This also means NO SPACE AND NO TAB between the area 0/1s.#
# #
# 3. See example files at:#
#    http://phylo.wikidot.com/biogeobears#files#
# #
# 4. Make you understand what a PLAIN-TEXT EDITOR is:#
#    http://phylo.wikidot.com/biogeobears#texteditors#
##
# 3. The PHYLIP format is the same format used for C++ LAGRANGE geography files.#
##
# 4. All names in the geography file must match names in the phylogeny file.#
##
# 5. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
##
# 6. Operational taxonomic units (OTUs) should ideally be phylogenetic lineages, #
#    i.e. genetically isolated populations.  These may or may not be identical #
#    with species.  You would NOT want to just use specimens, as each specimen #
#    automatically can only live in 1 area, which will typically favor DEC+J #
#    models.  This is fine if the species/lineages really do live in single areas,#
#    but you wouldn't want to assume this without thinking about it at least. #
#    In summary, you should collapse multiple specimens into species/lineages if #
#    data indicates they are the same genetic population.#
#######################################################
#
# This is the example geography file for Hawaiian Psychotria#
# (from Ree & Smith 2008)#
geogfn = np(paste(addslash(extdata_dir), "Psychotria_geog.data", sep=""))#
#
# Look at the raw geography text file:#
moref(geogfn)#
#
# Look at your geographic range data:#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Set the maximum number of areas any species may occupy; this cannot be larger #
# than the number of areas you set up, but it can be smaller.#
max_range_size = 4#
#
#####################################################
#####################################################
# KEY HINT: The number of states (= number of different possible geographic ranges)#
# depends on (a) the number of areas and (b) max_range_size.#
# If you have more than about 500-600 states, the calculations will get REALLY slow,#
# since the program has to exponentiate a matrix of e.g. 600x600.  Often the computer#
# will just sit there and crunch, and never get through the calculation of the first#
# likelihood.#
# #
# (this is also what is usually happening when LAGRANGE hangs: you have too many states!)#
##
# To check the number of states for a given number of ranges, try:#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=FALSE)#
numstates_from_numareas(numareas=4, maxareas=3, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=2, include_null_range=TRUE)#
#
# Large numbers of areas have problems:#
numstates_from_numareas(numareas=10, maxareas=10, include_null_range=TRUE)#
#
# ...unless you limit the max_range_size:#
numstates_from_numareas(numareas=10, maxareas=2, include_null_range=TRUE)#
#####################################################
#####################################################
#
########################################################
########################################################
# DEC AND DEC+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DEC" model is identical with #
# the Lagrange DEC model, and should return identical#
# ML estimates of parameters, and the same #
# log-likelihoods, for the same datasets.#
##
# Ancestral state probabilities at nodes will be slightly #
# different, since BioGeoBEARS is reporting the #
# ancestral state probabilities under the global ML#
# model, and Lagrange is reporting ancestral state#
# probabilities after re-optimizing the likelihood#
# after fixing the state at each node. These will #
# be similar, but not identical. See Matzke (2014),#
# Systematic Biology, for discussion.#
##
# Also see Matzke (2014) for presentation of the #
# DEC+J model.#
########################################################
########################################################
#
########################################################
########################################################
#
########################################################
# Run DEC#
########################################################
#
# Intitialize a default model (DEC model)#
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
#
# Give BioGeoBEARS the location of the phylogeny Newick file#
BioGeoBEARS_run_object$trfn = trfn#
#
# Give BioGeoBEARS the location of the geography text file#
BioGeoBEARS_run_object$geogfn = geogfn#
#
# Input the maximum range size#
BioGeoBEARS_run_object$max_range_size = max_range_size#
#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; OMeara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
# 1. Here, un-comment ONLY the files you want to use.#
# 2. Also un-comment "BioGeoBEARS_run_object = section_the_tree(...", below.#
# 3. For example files see (a) extdata_dir, #
#  or (b) http://phylo.wikidot.com/biogeobears#files#
#  and BioGeoBEARS Google Group posts for further hints)#
##
# Uncomment files you wish to use in time-stratified analyses:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
# (use more cores to speed it up; this requires#
# library(parallel) and/or library(snow). The package "parallel" #
# is now default on Macs in R 3.0+, but apparently still #
# has to be typed on some Windows machines. Note: apparently #
# parallel works on Mac command-line R, but not R.app.#
# BioGeoBEARS checks for this and resets to 1#
# core with R.app)#
#
# Sparse matrix exponentiation is an option for huge numbers of ranges/states (600+)#
# I have experimented with sparse matrix exponentiation in EXPOKIT/rexpokit,#
# but the results are imprecise and so I haven't explored it further.#
# In a Bayesian analysis, it might work OK, but the ML point estimates are#
# not identical.#
# Also, I have not implemented all functions to work with force_sparse=TRUE.#
# Volunteers are welcome to work on it!!#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC model#
# (nothing to do; defaults)#
#
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.#
BioGeoBEARS_run_object#
#
# This contains the model object#
BioGeoBEARS_run_object$BioGeoBEARS_model_object#
#
# This table contains the parameters of the model #
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table#
#
# Run this to check inputs. Read the error messages if you get them!#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# For a slow analysis, run once, then set runslow=FALSE to just #
# load the saved result.#
runslow = TRUE#
resfn = "Psychotria_DEC_M0_unconstrained_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDEC = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDEC = res#
    }#
#
########################################################
# Run DEC+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; OMeara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDEC$outputs@params_table["d","est"]#
estart = resDEC$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Add j as a free parameter#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "Psychotria_DEC+J_M0_unconstrained_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDECj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDECj = res#
    }#
#
########################################################
# PDF plots#
########################################################
pdffn = "Psychotria_DEC_vs_DEC+J_M0_unconstrained_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - DEC#
########################################################
analysis_titletxt ="BioGeoBEARS DEC on Psychotria M0_unconstrained"#
#
# Setup#
results_object = resDEC#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - DECJ#
########################################################
analysis_titletxt ="BioGeoBEARS DEC+J on Psychotria M0_unconstrained"#
#
# Setup#
results_object = resDECj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()  # Turn off PDF#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr) # Plot it
# Load the package (after installation, see above).#
library(optimx)         # You need to have some version of optimx available#
                        # as it is a BioGeoBEARS dependency; however, if you#
                        # don't want to use optimx, and use optim() (from R core) #
                        # you can set:#
                        # BioGeoBEARS_run_object$use_optimx = FALSE#
                        # ...everything should work either way -- NJM 2014-01-08#
library(FD)       # for FD::maxent() (make sure this is up-to-date)#
library(snow)     # (if you want to use multicore functionality; some systems/R versions prefer library(parallel), try either)#
library(parallel)#
library(BioGeoBEARS)#
#
#########################################################
# TO GET THE OPTIMX/OPTIM FIX, AND THE UPPASS FIX, #
# SOURCE THE REVISED FUNCTIONS WITH THESE COMMANDS#
##
# CRUCIAL CRUCIAL CRUCIAL: #
# YOU HAVE TO RUN THE SOURCE COMMANDS AFTER #
# *EVERY TIME* YOU DO library(BioGeoBEARS). THE CHANGES ARE NOT "PERMANENT", #
# THEY HAVE TO BE MADE EACH TIME.  IF YOU ARE GOING TO BE OFFLINE, #
# YOU CAN DOWNLOAD EACH .R FILE TO YOUR HARD DRIVE AND REFER THE source()#
# COMMANDS TO THE FULL PATH AND FILENAME OF EACH FILE ON YOUR#
# LOCAL SYSTEM INSTEAD.#
#########################################################
library(BioGeoBEARS)#
source("http://phylo.wdfiles.com/local--files/biogeobears/cladoRcpp.R") # (needed now that traits model added; source FIRST!)#
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_add_fossils_randomly_v1.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_basics_v1.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_calc_transition_matrices_v1.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_classes_v1.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_detection_v1.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_DNA_cladogenesis_sim_v1.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_extract_Qmat_COOmat_v1.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_generics_v1.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_models_v1.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_on_multiple_trees_v1.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_plots_v1.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_readwrite_v1.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_simulate_v1.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_SSEsim_makePlots_v1.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_SSEsim_v1.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_stochastic_mapping_v1.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_stratified_v1.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_univ_model_v1.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/calc_uppass_probs_v1.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/calc_loglike_sp_v01.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/get_stratified_subbranch_top_downpass_likelihoods_v1.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/runBSM_v1.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/stochastic_map_given_inputs.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/summarize_BSM_tables_v1.R")#
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_traits_v1.R") # added traits model#
calc_loglike_sp = compiler::cmpfun(calc_loglike_sp_prebyte)    # crucial to fix bug in uppass calculations#
calc_independent_likelihoods_on_each_branch = compiler::cmpfun(calc_independent_likelihoods_on_each_branch_prebyte)#
    # slight speedup hopefully#
#
########################################################
# Local source()-ing method -- uses BioGeoBEARS sourceall() function #
# on a directory of .R files, so you don't have to type them out.#
# The directories here are on my machine, you would have to make a #
# directory, save the .R files there, and refer to them.#
##
# NOTE: it's best to source the "cladoRcpp.R" update first, to avoid warnings like this:#
###
## Note: possible error in 'rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs = tmpca_1, ': #
##         unused arguments (m = m, m_null_range = include_null_range, jts_matrix = jts_matrix) #
###
##
# TO USE: Delete or comment out the 'source("http://...")' commands above, and un-comment#
#              the below...#
#########################################################################
# Un-comment (and fix directory paths) to use:#
#library(BioGeoBEARS)#
#source("/drives/Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp.R")#
#sourceall("/drives/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#calc_loglike_sp = compiler::cmpfun(calc_loglike_sp_prebyte)    # crucial to fix bug in uppass calculations#
#calc_independent_likelihoods_on_each_branch = compiler::cmpfun(calc_independent_likelihoods_on_each_branch_prebyte)#
#########################################################################
#
########################################################
# SETUP: YOUR WORKING DIRECTORY#
########################################################
# You will need to set your working directory to match your local system#
#
# Note these very handy functions!#
# Command "setwd(x)" sets your working directory#
# Command "getwd()" gets your working directory and tells you what it is.#
# Command "list.files()" lists the files in your working directory#
# To get help on any command, use "?".  E.g., "?list.files"#
#
# Set your working directory for output files#
# default here is your home directory ("~")#
# Change this as you like#
wd = np("~")#
setwd(wd)#
#
# Double-check your working directory with getwd()#
getwd()#
#
########################################################
# SETUP: Extension data directory#
########################################################
# When R packages contain extra files, they are stored in the "extdata" directory #
# inside the installed package.#
##
# BioGeoBEARS contains various example files and scripts in its extdata directory.#
# #
# Each computer operating system might install BioGeoBEARS in a different place, #
# depending on your OS and settings. #
# #
# However, you can find the extdata directory like this:#
extdata_dir = np(system.file("extdata", package="BioGeoBEARS"))#
extdata_dir#
list.files(extdata_dir)#
#
# "system.file" looks in the directory of a specified package (in this case BioGeoBEARS)#
# The function "np" is just a shortcut for normalizePath(), which converts the #
# path to the format appropriate for your system (e.g., Mac/Linux use "/", but #
# Windows uses "\\", if memory serves).#
#
# Even when using your own data files, you should KEEP these commands in your #
# script, since the plot_BioGeoBEARS_results function needs a script from the #
# extdata directory to calculate the positions of "corners" on the plot. This cannot#
# be made into a straight up BioGeoBEARS function because it uses C routines #
# from the package APE which do not pass R CMD check for some reason.#
#
########################################################
# SETUP: YOUR TREE FILE AND GEOGRAPHY FILE#
########################################################
# Example files are given below. To run your own data,#
# make the below lines point to your own files, e.g.#
# trfn = "/mydata/frogs/frogBGB/tree.newick"#
# geogfn = "/mydata/frogs/frogBGB/geog.data"#
#
########################################################
# Phylogeny file#
# Notes: #
# 1. Must be binary/bifurcating: no polytomies#
# 2. No negative branchlengths (e.g. BEAST MCC consensus trees sometimes have negative branchlengths)#
# 3. Be careful of very short branches, as BioGeoBEARS will interpret ultrashort branches as direct ancestors#
# 4. You can use non-ultrametric trees, but BioGeoBEARS will interpret any tips significantly below the #
#    top of the tree as fossils!  This is only a good idea if you actually do have fossils in your tree,#
#    as in e.g. Wood, Matzke et al. (2013), Systematic Biology.#
# 5. The default settings of BioGeoBEARS make sense for trees where the branchlengths are in units of #
#    millions of years, and the tree is 1-1000 units tall. If you have a tree with a total height of#
#    e.g. 0.00001, you will need to adjust e.g. the max values of d and e, or (simpler) multiply all#
#    your branchlengths to get them into reasonable units.#
# 6. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
########################################################
# This is the example Newick file for Hawaiian Psychotria#
# (from Ree & Smith 2008)#
# "trfn" = "tree file name"#
trfn = np(paste(addslash(extdata_dir), "Psychotria_5.2.newick", sep=""))#
#
# Look at the raw Newick file:#
moref(trfn)#
#
# Look at your phylogeny:#
tr = read.tree(trfn)#
tr#
plot(tr)#
title("Example Psychotria phylogeny from Ree & Smith (2008)")#
axisPhylo() # plots timescale#
#
########################################################
# Geography file#
# Notes:#
# 1. This is a PHYLIP-formatted file. This means that in the #
#    first line, #
#    - the 1st number equals the number of rows (species)#
#    - the 2nd number equals the number of columns (number of areas)#
#    - after a tab, put the areas in parentheses, with spaces: (A B C D)#
##
# 1.5. Example first line:#
#    10    4    (A B C D)#
# #
# 2. The second line, and subsequent lines:#
#    speciesA    0110#
#    speciesB    0111#
#    speciesC    0001#
#         ...#
# #
# 2.5a. This means a TAB between the species name and the area 0/1s#
# 2.5b. This also means NO SPACE AND NO TAB between the area 0/1s.#
# #
# 3. See example files at:#
#    http://phylo.wikidot.com/biogeobears#files#
# #
# 4. Make you understand what a PLAIN-TEXT EDITOR is:#
#    http://phylo.wikidot.com/biogeobears#texteditors#
##
# 3. The PHYLIP format is the same format used for C++ LAGRANGE geography files.#
##
# 4. All names in the geography file must match names in the phylogeny file.#
##
# 5. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
##
# 6. Operational taxonomic units (OTUs) should ideally be phylogenetic lineages, #
#    i.e. genetically isolated populations.  These may or may not be identical #
#    with species.  You would NOT want to just use specimens, as each specimen #
#    automatically can only live in 1 area, which will typically favor DEC+J #
#    models.  This is fine if the species/lineages really do live in single areas,#
#    but you wouldn't want to assume this without thinking about it at least. #
#    In summary, you should collapse multiple specimens into species/lineages if #
#    data indicates they are the same genetic population.#
#######################################################
#
# This is the example geography file for Hawaiian Psychotria#
# (from Ree & Smith 2008)#
geogfn = np(paste(addslash(extdata_dir), "Psychotria_geog.data", sep=""))#
#
# Look at the raw geography text file:#
moref(geogfn)#
#
# Look at your geographic range data:#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Set the maximum number of areas any species may occupy; this cannot be larger #
# than the number of areas you set up, but it can be smaller.#
max_range_size = 4#
#
#####################################################
#####################################################
# KEY HINT: The number of states (= number of different possible geographic ranges)#
# depends on (a) the number of areas and (b) max_range_size.#
# If you have more than about 500-600 states, the calculations will get REALLY slow,#
# since the program has to exponentiate a matrix of e.g. 600x600.  Often the computer#
# will just sit there and crunch, and never get through the calculation of the first#
# likelihood.#
# #
# (this is also what is usually happening when LAGRANGE hangs: you have too many states!)#
##
# To check the number of states for a given number of ranges, try:#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=FALSE)#
numstates_from_numareas(numareas=4, maxareas=3, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=2, include_null_range=TRUE)#
#
# Large numbers of areas have problems:#
numstates_from_numareas(numareas=10, maxareas=10, include_null_range=TRUE)#
#
# ...unless you limit the max_range_size:#
numstates_from_numareas(numareas=10, maxareas=2, include_null_range=TRUE)#
#####################################################
#####################################################
#
########################################################
########################################################
# DEC AND DEC+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DEC" model is identical with #
# the Lagrange DEC model, and should return identical#
# ML estimates of parameters, and the same #
# log-likelihoods, for the same datasets.#
##
# Ancestral state probabilities at nodes will be slightly #
# different, since BioGeoBEARS is reporting the #
# ancestral state probabilities under the global ML#
# model, and Lagrange is reporting ancestral state#
# probabilities after re-optimizing the likelihood#
# after fixing the state at each node. These will #
# be similar, but not identical. See Matzke (2014),#
# Systematic Biology, for discussion.#
##
# Also see Matzke (2014) for presentation of the #
# DEC+J model.#
########################################################
########################################################
#
########################################################
########################################################
#
########################################################
# Run DEC#
########################################################
#
# Intitialize a default model (DEC model)#
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
#
# Give BioGeoBEARS the location of the phylogeny Newick file#
BioGeoBEARS_run_object$trfn = trfn#
#
# Give BioGeoBEARS the location of the geography text file#
BioGeoBEARS_run_object$geogfn = geogfn#
#
# Input the maximum range size#
BioGeoBEARS_run_object$max_range_size = max_range_size#
#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; OMeara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
# 1. Here, un-comment ONLY the files you want to use.#
# 2. Also un-comment "BioGeoBEARS_run_object = section_the_tree(...", below.#
# 3. For example files see (a) extdata_dir, #
#  or (b) http://phylo.wikidot.com/biogeobears#files#
#  and BioGeoBEARS Google Group posts for further hints)#
##
# Uncomment files you wish to use in time-stratified analyses:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
# (use more cores to speed it up; this requires#
# library(parallel) and/or library(snow). The package "parallel" #
# is now default on Macs in R 3.0+, but apparently still #
# has to be typed on some Windows machines. Note: apparently #
# parallel works on Mac command-line R, but not R.app.#
# BioGeoBEARS checks for this and resets to 1#
# core with R.app)#
#
# Sparse matrix exponentiation is an option for huge numbers of ranges/states (600+)#
# I have experimented with sparse matrix exponentiation in EXPOKIT/rexpokit,#
# but the results are imprecise and so I haven't explored it further.#
# In a Bayesian analysis, it might work OK, but the ML point estimates are#
# not identical.#
# Also, I have not implemented all functions to work with force_sparse=TRUE.#
# Volunteers are welcome to work on it!!#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC model#
# (nothing to do; defaults)#
#
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.#
BioGeoBEARS_run_object#
#
# This contains the model object#
BioGeoBEARS_run_object$BioGeoBEARS_model_object#
#
# This table contains the parameters of the model #
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table#
#
# Run this to check inputs. Read the error messages if you get them!#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# For a slow analysis, run once, then set runslow=FALSE to just #
# load the saved result.#
runslow = TRUE#
resfn = "Psychotria_DEC_M0_unconstrained_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDEC = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDEC = res#
    }#
#
########################################################
# Run DEC+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; OMeara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDEC$outputs@params_table["d","est"]#
estart = resDEC$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Add j as a free parameter#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "Psychotria_DEC+J_M0_unconstrained_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDECj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDECj = res#
    }#
#
########################################################
# PDF plots#
########################################################
pdffn = "Psychotria_DEC_vs_DEC+J_M0_unconstrained_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - DEC#
########################################################
analysis_titletxt ="BioGeoBEARS DEC on Psychotria M0_unconstrained"#
#
# Setup#
results_object = resDEC#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - DECJ#
########################################################
analysis_titletxt ="BioGeoBEARS DEC+J on Psychotria M0_unconstrained"#
#
# Setup#
results_object = resDECj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()  # Turn off PDF#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr) # Plot it#
#
########################################################
########################################################
# DIVALIKE AND DIVALIKE+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DIVALIKE" model is not identical with #
# Ronquist (1997)'s parsimony DIVA. It is a likelihood#
# interpretation of DIVA, constructed by modelling DIVA's#
# processes the way DEC does, but only allowing the #
# processes DIVA allows (widespread vicariance: yes; subset#
# sympatry: no; see Ronquist & Sanmartin 2011, Figure 4).#
##
# DIVALIKE is a likelihood interpretation of parsimony#
# DIVA, and it is "like DIVA" -- similar to, but not#
# identical to, parsimony DIVA.#
##
# I thus now call the model "DIVALIKE", and you should also. ;-)#
########################################################
########################################################
#
########################################################
# Run DIVALIKE#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; OMeara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DIVALIKE model#
# Remove subset-sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "2-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "ysv*1/2"#
#
# Allow classic, widespread vicariance; all events equiprobable#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","init"] = 0.5#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","est"] = 0.5#
#
# No jump dispersal/founder-event speciation#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = 0.01#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = 0.01#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
runslow = TRUE#
resfn = "Psychotria_DIVALIKE_M0_unconstrained_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDIVALIKE = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDIVALIKE = res#
    }#
#
########################################################
# Run DIVALIKE+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; OMeara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DIVALIKE+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDIVALIKE$outputs@params_table["d","est"]#
estart = resDIVALIKE$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Remove subset-sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "2-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "ysv*1/2"#
#
# Allow classic, widespread vicariance; all events equiprobable#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","init"] = 0.5#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","est"] = 0.5#
#
# Add jump dispersal/founder-event speciation#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
# Under DIVALIKE+J, the max of "j" should be 2, not 3 (as is default in DEC+J)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","min"] = 0.00001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 1.99999#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "Psychotria_DIVALIKE+J_M0_unconstrained_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDIVALIKEj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDIVALIKEj = res#
    }#
#
pdffn = "Psychotria_DIVALIKE_vs_DIVALIKE+J_M0_unconstrained_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - DIVALIKE#
########################################################
analysis_titletxt ="BioGeoBEARS DIVALIKE on Psychotria M0_unconstrained"#
#
# Setup#
results_object = resDIVALIKE#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - DIVALIKE+J#
########################################################
analysis_titletxt ="BioGeoBEARS DIVALIKE+J on Psychotria M0_unconstrained"#
#
# Setup#
results_object = resDIVALIKEj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)#
#
########################################################
########################################################
# BAYAREALIKE AND BAYAREALIKE+J ANALYSIS#
########################################################
########################################################
# NOTE: As with DIVA, the BioGeoBEARS BayArea-like model is #
# not identical with the full Bayesian model implemented #
# in the "BayArea" program of Landis et al. (2013). #
##
# Instead, this is a simplified likelihood interpretation#
# of the model.  Basically, in BayArea and BioGeoBEARS-BAYAREALIKE, #
# "d" and "e" work like they do in the DEC model of Lagrange #
# (and BioGeoBEARS), and then BayArea's cladogenesis assumption#
# (which is that nothing in particular happens at cladogenesis) is #
# replicated by BioGeoBEARS.#
##
# This leaves out 3 important things that are in BayArea:#
# 1. Distance dependence (you can add this with a distances #
#    matrix + the "x" parameter in BioGeoBEARS, however)#
# 2. A correction for disallowing "e" events that drive#
#    a species extinct (a null geographic range)#
# 3. The neat Bayesian sampling of histories, which allows#
#    analyses on large numbers of areas.#
##
# The main purpose of having a "BAYAREALIKE" model is #
# to test the importance of the cladogenesis model on #
# particular datasets. Does it help or hurt the data #
# likelihood if there is no special cladogenesis process?#
# #
# BAYAREALIKE is a likelihood interpretation of BayArea,#
# and it is "like BayArea" -- similar to, but not#
# identical to, Bayesian BayArea.#
# I thus now call the model "BAYAREALIKE", and you should also. ;-)#
########################################################
########################################################
#
########################################################
# Run BAYAREALIKE#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; OMeara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up BAYAREALIKE model#
# No subset sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
# No vicariance#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","est"] = 0.0#
#
# No jump dispersal/founder-event speciation#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = 0.01#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = 0.01#
#
# Adjust linkage between parameters#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "1-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/1"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "1-j"#
#
# Only sympatric/range-copying (y) events allowed, and with #
# exact copying (both descendants always the same size as the ancestor)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","init"] = 0.9999#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","est"] = 0.9999#
#
# Check the inputs#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
runslow = TRUE#
resfn = "Psychotria_BAYAREALIKE_M0_unconstrained_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resBAYAREALIKE = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resBAYAREALIKE = res#
    }#
#
########################################################
# Run BAYAREALIKE+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; OMeara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up BAYAREALIKE+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resBAYAREALIKE$outputs@params_table["d","est"]#
estart = resBAYAREALIKE$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# No subset sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
# No vicariance#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","est"] = 0.0#
#
# *DO* allow jump dispersal/founder-event speciation (set the starting value close to 0)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
# Under BAYAREALIKE+J, the max of "j" should be 1, not 3 (as is default in DEC+J) or 2 (as in DIVALIKE+J)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 0.99999#
#
# Adjust linkage between parameters#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "1-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/1"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "1-j"#
#
# Only sympatric/range-copying (y) events allowed, and with #
# exact copying (both descendants always the same size as the ancestor)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","init"] = 0.9999#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","est"] = 0.9999#
#
# NOTE (NJM, 2014-04): BAYAREALIKE+J seems to crash on some computers, usually Windows #
# machines. I can't replicate this on my Mac machines, but it is almost certainly#
# just some precision under-run issue, when optim/optimx tries some parameter value #
# just below zero.  The "min" and "max" options on each parameter are supposed to#
# prevent this, but apparently optim/optimx sometimes go slightly beyond #
# these limits.  Anyway, if you get a crash, try raising "min" and lowering "max" #
# slightly for each parameter:#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","min"] = 0.0000001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","max"] = 4.9999999#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","min"] = 0.0000001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","max"] = 4.9999999#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","min"] = 0.00001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 0.99999#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "Psychotria_BAYAREALIKE+J_M0_unconstrained_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resBAYAREALIKEj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resBAYAREALIKEj = res#
    }#
#
pdffn = "Psychotria_BAYAREALIKE_vs_BAYAREALIKE+J_M0_unconstrained_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - BAYAREALIKE#
########################################################
analysis_titletxt ="BioGeoBEARS BAYAREALIKE on Psychotria M0_unconstrained"#
#
# Setup#
results_object = resBAYAREALIKE#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - BAYAREALIKE+J#
########################################################
analysis_titletxt ="BioGeoBEARS BAYAREALIKE+J on Psychotria M0_unconstrained"#
#
# Setup#
results_object = resBAYAREALIKEj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)#
#
##########################################################################
##########################################################################
##########################################################################
##########################################################################
# #
# CALCULATE SUMMARY STATISTICS TO COMPARE#
# DEC, DEC+J, DIVALIKE, DIVALIKE+J, BAYAREALIKE, BAYAREALIKE+J#
# #
##########################################################################
##########################################################################
##########################################################################
##########################################################################
#
##########################################################################
##########################################################################
# REQUIRED READING:#
##
# Practical advice / notes / basic principles on statistical model #
#    comparison in general, and in BioGeoBEARS:#
# http://phylo.wikidot.com/advice-on-statistical-model-comparison-in-biogeobears#
##########################################################################
##########################################################################
#
# Set up empty tables to hold the statistical results#
restable = NULL#
teststable = NULL#
#
########################################################
# Statistics -- DEC vs. DEC+J#
########################################################
# We have to extract the log-likelihood differently, depending on the #
# version of optim/optimx#
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resDEC)#
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resDECj)#
#
numparams1 = 3#
numparams2 = 2#
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)#
stats#
#
# DEC, null model for Likelihood Ratio Test (LRT)#
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resDEC, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
# DEC+J, alternative model for Likelihood Ratio Test (LRT)#
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resDECj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
#
# The null hypothesis for a Likelihood Ratio Test (LRT) is that two models#
# confer the same likelihood on the data. See: Brian O'Meara's webpage:#
# http://www.brianomeara.info/tutorials/aic#
# ...for an intro to LRT, AIC, and AICc#
#
rbind(res2, res1)#
tmp_tests = conditional_format_table(stats)#
#
restable = rbind(restable, res2, res1)#
teststable = rbind(teststable, tmp_tests)#
#
########################################################
# Statistics -- DIVALIKE vs. DIVALIKE+J#
########################################################
# We have to extract the log-likelihood differently, depending on the #
# version of optim/optimx#
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resDIVALIKE)#
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resDIVALIKEj)#
#
numparams1 = 3#
numparams2 = 2#
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)#
stats#
#
# DIVALIKE, null model for Likelihood Ratio Test (LRT)#
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resDIVALIKE, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
# DIVALIKE+J, alternative model for Likelihood Ratio Test (LRT)#
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resDIVALIKEj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
#
rbind(res2, res1)#
conditional_format_table(stats)#
#
tmp_tests = conditional_format_table(stats)#
#
restable = rbind(restable, res2, res1)#
teststable = rbind(teststable, tmp_tests)#
#
########################################################
# Statistics -- BAYAREALIKE vs. BAYAREALIKE+J#
########################################################
# We have to extract the log-likelihood differently, depending on the #
# version of optim/optimx#
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resBAYAREALIKE)#
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resBAYAREALIKEj)#
#
numparams1 = 3#
numparams2 = 2#
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)#
stats#
#
# BAYAREALIKE, null model for Likelihood Ratio Test (LRT)#
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resBAYAREALIKE, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
# BAYAREALIKE+J, alternative model for Likelihood Ratio Test (LRT)#
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resBAYAREALIKEj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
#
rbind(res2, res1)#
conditional_format_table(stats)#
#
tmp_tests = conditional_format_table(stats)#
#
restable = rbind(restable, res2, res1)#
teststable = rbind(teststable, tmp_tests)#
#
##########################################################################
# ASSEMBLE RESULTS TABLES: DEC, DEC+J, DIVALIKE, DIVALIKE+J, BAYAREALIKE, BAYAREALIKE+J#
##########################################################################
teststable$alt = c("DEC+J", "DIVALIKE+J", "BAYAREALIKE+J")#
teststable$null = c("DEC", "DIVALIKE", "BAYAREALIKE")#
row.names(restable) = c("DEC", "DEC+J", "DIVALIKE", "DIVALIKE+J", "BAYAREALIKE", "BAYAREALIKE+J")#
restable = put_jcol_after_ecol(restable)#
restable#
#
# Look at the results!!#
restable#
teststable#
#
########################################################
# Save the results tables for later -- check for e.g.#
# convergence issues#
########################################################
#
# Loads to "restable"#
save(restable, file="restable_v1.Rdata")#
load(file="restable_v1.Rdata")#
#
# Loads to "teststable"#
save(teststable, file="teststable_v1.Rdata")#
load(file="teststable_v1.Rdata")#
#
# Also save to text files#
write.table(restable, file="restable.txt", quote=FALSE, sep="\t")#
write.table(unlist_df(teststable), file="teststable.txt", quote=FALSE, sep="\t")#
#
########################################################
# Model weights of all six models#
########################################################
restable2 = restable#
#
# With AICs:#
AICtable = calc_AIC_column(LnL_vals=restable$LnL, nparam_vals=restable$numparams)#
restable = cbind(restable, AICtable)#
restable_AIC_rellike = AkaikeWeights_on_summary_table(restable=restable, colname_to_use="AIC")#
restable_AIC_rellike = put_jcol_after_ecol(restable_AIC_rellike)#
restable_AIC_rellike#
#
# With AICcs -- factors in sample size#
samplesize = length(tr$tip.label)#
AICtable = calc_AICc_column(LnL_vals=restable$LnL, nparam_vals=restable$numparams, samplesize=samplesize)#
restable2 = cbind(restable2, AICtable)#
restable_AICc_rellike = AkaikeWeights_on_summary_table(restable=restable2, colname_to_use="AICc")#
restable_AICc_rellike = put_jcol_after_ecol(restable_AICc_rellike)#
restable_AICc_rellike#
#
# Also save to text files#
write.table(restable_AIC_rellike, file="restable_AIC_rellike.txt", quote=FALSE, sep="\t")#
write.table(restable_AICc_rellike, file="restable_AICc_rellike.txt", quote=FALSE, sep="\t")#
#
# Save with nice conditional formatting#
write.table(conditional_format_table(restable_AIC_rellike), file="restable_AIC_rellike_formatted.txt", quote=FALSE, sep="\t")#
write.table(conditional_format_table(restable_AICc_rellike), file="restable_AICc_rellike_formatted.txt", quote=FALSE, sep="\t")
# Load the package (after installation, see above).#
library(optimx)         # You need to have some version of optimx available#
                        # as it is a BioGeoBEARS dependency; however, if you#
                        # don't want to use optimx, and use optim() (from R core) #
                        # you can set:#
                        # BioGeoBEARS_run_object$use_optimx = FALSE#
                        # ...everything should work either way -- NJM 2014-01-08#
library(FD)       # for FD::maxent() (make sure this is up-to-date)#
library(snow)     # (if you want to use multicore functionality; some systems/R versions prefer library(parallel), try either)#
library(parallel)#
library(BioGeoBEARS)#
#
source("/drives/Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp.R")#
sourceall("/drives/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
calc_loglike_sp = compiler::cmpfun(calc_loglike_sp_prebyte)    # crucial to fix bug in uppass calculations#
calc_independent_likelihoods_on_each_branch = compiler::cmpfun(calc_independent_likelihoods_on_each_branch_prebyte)#
wd = "/drives/GDrive/__GDrive_projects/2017-06-20_27_Evolution2017_Portland/test/write_areas/"#
setwd(wd)#
#
geogfn = "geog_3areas.data"#
#
# Look at the raw geography text file:#
moref(geogfn)#
#
# Look at your geographic range data:#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
# Make a list of all possible ranges at one tip#
# (including the null range)#
# 3 areas means 2^3 = 8 possible ranges#
possible_ranges = c(#
"000",#
"100",#
"010",#
"001",#
"110",#
"011",#
"101",#
"111")#
#
# Of course, for 2 tips, there will be 8x8=64 possible data patterns.  #
# So, we need to make a geography file for each one.#
#
new_fns = NULL#
for (i in 1:length(possible_ranges))#
	{#
	for (j in 1:length(possible_ranges))#
		{#
		sp1_range = possible_ranges[i]#
		sp2_range = possible_ranges[j]#
		tipranges_new = tipranges#
		tipranges_new@df[1,] = strsplit(sp1_range, split="")[[1]]#
		tipranges_new@df[2,] = strsplit(sp2_range, split="")[[1]]#
		new_fn = paste0("geog_", sp1_range, "_", sp2_range, ".data")#
		new_fns = c(new_fns, new_fn)#
		save_tipranges_to_LagrangePHYLIP(tipranges_object=tipranges_new, lgdata_fn=new_fn)#
		} # END for (j in 1:length(possible_ranges))#
	} # END for (i in 1:length(possible_ranges))#
# Let's get the likelihoods under the DEC model,#
# for some particular parameters#
# (here, d and e are very low, allowing us to see #
# a pure cladogenetic-range-change model#
#
# DEC likelihoods#
trfn = "tree.newick"#
lnLs = NULL#
for (i in 1:length(new_fns))#
	{#
	max_range_size = 3#
	trfn = trfn#
	geogfn = new_fns[[i]]#
	tr = read.tree(trfn)#
	tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
	BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
	BioGeoBEARS_run_object$trfn = trfn#
	BioGeoBEARS_run_object$geogfn = geogfn#
	BioGeoBEARS_run_object$max_range_size = max_range_size#
	BioGeoBEARS_run_object$min_branchlength = 0.000001#
	BioGeoBEARS_run_object$include_null_range = TRUE#
	BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
	BioGeoBEARS_run_object$return_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_ancprobs = TRUE#
	BioGeoBEARS_run_object$num_cores_to_use = 1#
	BioGeoBEARS_run_object$allow_null_tips = TRUE#
#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "est"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "init"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "est"] = 0.00001#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "type"] = "fixed"#
	res = bears_optim_run(BioGeoBEARS_run_object, skip_optim=TRUE)	#
	lnL = res#
	lnLs = c(lnLs, lnL)#
	}#
#
DEC_lnLs = lnLs#
DEC_lnLs#
exp(DEC_lnLs)#
#
tab_DEC = cbind(new_fns, round(DEC_lnLs,4), round(exp(DEC_lnLs),3))#
tab_DEC = as.data.frame(tab_DEC)#
tab_DEC = dfnums_to_numeric(tab_DEC)#
tab_DEC#
#
# What do the likelihoods of all the data add up to?#
sum(exp(DEC_lnLs))#
# 7#
# (works -- 7 possible ancestral states, excluding null range)#
#
# They don't add up to 8, because the probability of any possible tip data,#
# when the ancestor has range null, is zero.  I guess technically I could#
# have programmed the model such that an ancestral null range is "transmitted" #
# through the cladogenesis model and up the branches, producing null#
# ranges at all tips with probability 1...but what's the point?#
# Let's repeat for some other values of d and e#
# d = 0.2#
# e = 0.1#
# DEC likelihoods#
trfn = "tree.newick"#
lnLs = NULL#
for (i in 1:length(new_fns))#
	{#
	max_range_size = 3#
	trfn = trfn#
	geogfn = new_fns[[i]]#
	tr = read.tree(trfn)#
	tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
	BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
	BioGeoBEARS_run_object$trfn = trfn#
	BioGeoBEARS_run_object$geogfn = geogfn#
	BioGeoBEARS_run_object$max_range_size = max_range_size#
	BioGeoBEARS_run_object$min_branchlength = 0.000001#
	BioGeoBEARS_run_object$include_null_range = TRUE#
	BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
	BioGeoBEARS_run_object$return_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_ancprobs = TRUE#
	BioGeoBEARS_run_object$num_cores_to_use = 1#
	BioGeoBEARS_run_object$allow_null_tips = TRUE#
#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "init"] = 0.2#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "est"] = 0.2#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "init"] = 0.1#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "est"] = 0.1#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "type"] = "fixed"#
	res = bears_optim_run(BioGeoBEARS_run_object, skip_optim=TRUE)	#
	lnL = res#
	lnLs = c(lnLs, lnL)#
	}#
#
DEC_lnLs = lnLs#
DEC_lnLs#
exp(DEC_lnLs)#
#
tab_DEC = cbind(new_fns, round(DEC_lnLs,4), round(exp(DEC_lnLs),3))#
tab_DEC = as.data.frame(tab_DEC)#
tab_DEC = dfnums_to_numeric(tab_DEC)#
tab_DEC#
#
# What do the likelihoods of all the data add up to?#
sum(exp(DEC_lnLs))#
# 7#
# Yep, 7 again...#
# DEC+J likelihoods, with an intermediate model#
trfn = "tree.newick"#
lnLs = NULL#
for (i in 1:length(new_fns))#
	{#
	max_range_size = 3#
	trfn = trfn#
	geogfn = new_fns[[i]]#
	BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
	BioGeoBEARS_run_object$trfn = trfn#
	BioGeoBEARS_run_object$geogfn = geogfn#
	BioGeoBEARS_run_object$max_range_size = max_range_size#
	BioGeoBEARS_run_object$min_branchlength = 0.000001#
	BioGeoBEARS_run_object$include_null_range = TRUE#
	BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
	BioGeoBEARS_run_object$return_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
	BioGeoBEARS_run_object$calc_ancprobs = TRUE#
	BioGeoBEARS_run_object$num_cores_to_use = 1#
	BioGeoBEARS_run_object$allow_null_tips = TRUE#
#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "init"] = 0.2#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d", "est"] = 0.2#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "init"] = 0.1#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "est"] = 0.1#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e", "type"] = "fixed"#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j", "init"] = 0.15#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j", "est"] = 0.15#
	BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j", "type"] = "fixed"#
	res = bears_optim_run(BioGeoBEARS_run_object, skip_optim=TRUE)	#
	lnL = res#
	lnLs = c(lnLs, lnL)#
	}#
#
DECj_lnLs = lnLs#
exp(DECj_lnLs)#
#
tab_DECj = cbind(new_fns, round(DECj_lnLs,4), round(exp(DECj_lnLs),3))#
tab_DECj = as.data.frame(tab_DECj)#
tab_DECj = dfnums_to_numeric(tab_DECj)#
tab_DECj#
sum(exp(DECj_lnLs))#
# 7#
# 7, again...
sum(exp(DEC_lnLs))#
sum(exp(DECj_lnLs))
write.table(tab_DEC, file="tab_DEC.txt", sep="\t")#
write.table(tab_DECj, file="tab_DECj.txt", sep="\t")
/drives/GDrive/__GDrive_projects/2017-06-20_27_Evolution2017_Portland/test/test_ClaSSE
########################################################
# #
# This script demonstrates how the biogeography models#
# DEC and DEC+J can be shown to be special cases of #
# the ClaSSE model (Goldberg & Igic 2012). That is, an #
# appropriately parameterized ClaSSE will produce a#
# likelihood calculation identical to that of DEC or DEC+J.#
# #
# Specifically, if one assumes:#
# #
# 1. A Yule process (pure-birth) produced the tree#
# #
# 2. Speciation and extinction rate are state-independent#
##
# Details include:#
##
# 3. DEC and DEC+J do not calculate the likelihood of the tree#
#    under a birth/death model. But, given assumptions 1 & 2,#
#    it is trivial to calculate the tree likelihood under a #
#    Yule process and either add this to DEC/DEC+J, or #
#    subtract it from ClaSEE.#
##
# 4. DEC and DEC+J do not use an extra likelihood calculation#
#    for the states at the root. This either has to be added#
#    to DEC/DEC+J, or subtracted from the ClaSSE likelihood.#
# #
# 5. To make the models equivalent, we have to include the #
#    geographic range of "null" (living in no areas) as a #
#    state in the state space.  Peculiarly, this means that #
#    a lineage could keep existing even while living in no #
#    areas.  Practically, this doesn't affect the downpass likelihood #
#    calculations, since under the DEC anagenesis model, it #
#    is impossible to evolve out of the null state; therefore#
#    it is impossible to have "null" as an ancestor state if #
#    all the tips have positive ranges; therefore the likelihood#
#    of the data for state "null" is always 0, all the way #
#    down to the root during downpass.#
# #
########################################################
########################################################
# OUTLINE#
# #
# 1. Calculation of tip state likelihoods under DEC, in #
#    BioGeoBEARS#
##
# 2. Calculation of tree likelihood under a Yule process#
# #
# 3. Set up of equivalent ClaSSE model#
##
# 4. ClaSSE likelihoods and comparison to DEC#
# #
########################################################
#
# Set your working directory to wherever you unzipped this directory#
wd = "/drives/GDrive/__GDrive_projects/2017-06-20_27_Evolution2017_Portland/test/test_ClaSSE/"#
setwd(wd)
library(diversitree)#
#
# After installation, load the package, dependencies, updates#
library(optimx)#
library(FD)#
library(snow)#
library(parallel)#
library(BioGeoBEARS)#
source("/drives/Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp.R")#
sourceall("/drives/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
calc_loglike_sp = compiler::cmpfun(calc_loglike_sp_prebyte)    # crucial to fix bug in uppass calculations#
calc_independent_likelihoods_on_each_branch = compiler::cmpfun(calc_independent_likelihoods_on_each_branch_prebyte)
extdata_dir = np(system.file("extdata", package="BioGeoBEARS"))#
# Look at your phylogeny:#
trfn = "tree.newick"#
tr = read.tree(trfn)#
tr#
plot(tr)#
title("Example phylogeny")#
axisPhylo() # plots timescale#
#
# Look your geography data at the tips:#
geogfn = "geog.data"#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Set the maximum number of areas any species may occupy; this cannot be larger #
# than the number of areas you set up, but it can be smaller.#
max_range_size = 2
dvals = c(0, 0.01, 0.05, 0.1, 0.3, 1, 3, 5)#
evals = c(0, 0.01, 0.05, 0.1, 0.3, 1, 3, 5)#
jvals = c(0, 0.01, 0.05, 0.1, 0.3, 1, 2.99)#
results = NULL#
for (d_val in dvals) {#
for (e_val in evals) {#
for (j_val in jvals) {#
#
########################################################
# Run DEC#
########################################################
#
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$force_sparse=FALSE    # sparse=FALSE causes pathology & isn't much faster at this scale#
BioGeoBEARS_run_object$speedup=TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$calc_ancprobs=TRUE    # get ancestral states from optim run#
# Input the maximum range size#
BioGeoBEARS_run_object$max_range_size = max_range_size#
# Multicore processing if desired#
BioGeoBEARS_run_object$num_cores_to_use=1#
BioGeoBEARS_run_object$force_sparse=FALSE#
#
# Give BioGeoBEARS the location of the geography text file#
BioGeoBEARS_run_object$geogfn = geogfn#
#
# Give BioGeoBEARS the location of the phylogeny Newick file#
BioGeoBEARS_run_object$trfn = trfn#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE#
#
# Set up DEC model#
# (nothing to do; defaults)#
#
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.#
BioGeoBEARS_run_object#
#
# This contains the model object#
BioGeoBEARS_run_object$BioGeoBEARS_model_object#
#
# This table contains the parameters of the model #
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table#
#
# Run this to check inputs. Read the error messages if you get them!#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Set the initial values for the "d" and "e" parameters#
dstart = d_val#
estart = e_val#
jstart = j_val#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","min"] = 0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","max"] = 5#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","min"] = 0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","max"] = 5#
# Do the likelihood calculation under these set parameters#
# (this is just 1 likelihood calculation, not an ML search)#
BGB_DEC_init_LnL = bears_optim_run(BioGeoBEARS_run_object, skip_optim=TRUE)#
BGB_DEC_init_LnL#
########################################################
########################################################
# 2. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
library(ape)#
trfn = "tree.newick"#
tr = read.tree(trfn)#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
birthRate = 0.22222222222222222222222222222222222222222222#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
########################################################
########################################################
# 3. Set up of equivalent ClaSSE model for DEC, starting values#
########################################################
########################################################
###################################################
# Set up states for ClaSSE to match DEC states#
###################################################
#
# States in the ClaSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
states = c(2, 2, 2, 3)#
names(states) = tr$tip.label#
states#
# Proportion of species in each state#
# (Let's assume we have all species)#
sampling.f = c(1,1,1,1)#
#
# Number of states#
k = 4#
#
# Make the ClaSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
classe_2areas = make.classe(tree=tr, states=states, k=4, sampling.f=sampling.f, strict=FALSE)#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
classe_2areas#
###################################################
# Set up parameters for ClaSSE to match DEC#
###################################################
# The names of the parameters:#
param_names = argnames(classe_2areas)#
#
# Most parameters will be zero#
classe_params = rep(0, times=length(param_names))#
names(classe_params) = param_names#
#
# All extinction rates are the same (state-independent)#
# Here, deathRate is 0 for all states#
classe_params[grepl(pattern="mu", x=param_names)] = deathRate#
#
# Transition rates are mostly 0, except as specified#
# by DEC anagenesis model#
d = d_val#
e = e_val#
classe_params[grepl(pattern="q", x=param_names)] = 0#
classe_params[param_names == "q21"] = e#
classe_params[param_names == "q31"] = e#
classe_params[param_names == "q24"] = d#
classe_params[param_names == "q34"] = d#
classe_params[param_names == "q42"] = e#
classe_params[param_names == "q43"] = e#
classe_params#
# The birthRate (lambda) is state-independent.  However, #
# only certain cladogenesis scenarios are allowed under DEC.#
##
# Disallowed cladogenesis scenarios have a rate of 0.#
##
# If there is more than one cladogenesis scenario conditional #
# on a certain ancestor, DEC assigns each a weight of 1, and #
# then divides by the sum of the weights. I.e., if there are#
# six possible cladogenetic range-inheritance events, they #
# each get a conditional probability of 1/6.#
# #
# To translate to ClaSSE, if the speciation rate for a lineage #
# in a certain state is lambda, then the rate of each individual #
# allowed scenario would be lambda * 1/6#
# #
y_val = (3-j_val)/3#
total_of_weights = y_val + j_val + j_val#
yprob = y_val / total_of_weights#
jprob = j_val / total_of_weights#
# Specifying the nonzero lambdas#
# Null range cannot speciate (doesn't seem to matter anyway,#
# as "null" cannot be an ancestor anyway)#
classe_params[param_names=="lambda111"] = birthRate#
#
# Narrow sympatry (ancestor A or B; rangesize of 1 area)#
classe_params[param_names=="lambda222"] = yprob * birthRate#
classe_params[param_names=="lambda333"] = yprob * birthRate#
#
# Jump dispersal speciation#
classe_params[param_names=="lambda223"] = jprob * birthRate#
classe_params[param_names=="lambda323"] = jprob * birthRate#
#
# Subset sympatry for state AB#
classe_params[param_names=="lambda424"] = 1/6 * birthRate#
classe_params[param_names=="lambda434"] = 1/6 * birthRate#
#
# Vicariance for state AB#
classe_params[param_names=="lambda423"] = 1/6 * birthRate#
#
classe_params_DEC = classe_params#
# Note: Under ClaSSE, these rates are implicitly assigned#
# to the branch rotations:#
##
# lambda424 is automatically also assigned to lambda442#
# lambda434 is automatically also assigned to lambda443#
# lambda423 is automatically also assigned to lambda432#
# #
# Note that this symmetry assumption would exclude modeling#
# of directional bias in founder-event speciation events#
#
# Calculate the ClaSSE likelihood under these parameters#
# Note that decision about the likelihood of the root states effects the LnL#
res1 = classe_2areas(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2 = classe_2areas(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.1,0.2,0.3,0.4)#
res3 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.0,1/3,1/3,1/3)#
res4 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25,0.25,0.25,0.25)#
res5 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
#
LnLs = rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5)#
print(LnLs)#
#
# You should get:#
# d=0.01, e=0.01#
# LnLs1 -6.889914 -5.098155#
# LnLs2 -8.835824 -5.098155#
# LnLs3 -8.276209 -5.098155#
# LnLs4 -8.499352 -5.098155#
# LnLs5 -8.835824 -5.098155#
#
# d=0.00, e=0.01#
# LnLs1 -6.842303 -5.050085#
# LnLs2 -8.788213 -5.050085#
# LnLs3 -8.228597 -5.050085#
# LnLs4 -8.451741 -5.050085#
# LnLs5 -8.788213 -5.050085#
# Calculate the likelihood under these parameters#
res1 = classe_2areas(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = classe_2areas(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.1,0.2,0.3,0.4)#
res3 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.0,1/3,1/3,1/3)#
res4 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25,0.25,0.25,0.25)#
res5 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
#
LnLs = rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5)#
print(LnLs)#
#
# You should get:#
# d=0.01, e=0.01#
# LnLs1  -9.087139 -5.098155#
# LnLs2 -10.473433 -5.098155#
# LnLs3 -10.003430 -5.098155#
# LnLs4 -10.185751 -5.098155#
# LnLs5 -10.473433 -5.098155#
#
# d=0.00, e=0.01#
# LnLs1  -9.039527 -5.050085#
# LnLs2 -10.425822 -5.050085#
# LnLs3  -9.955818 -5.050085#
# LnLs4 -10.138140 -5.050085#
# LnLs5 -10.425822 -5.050085#
#
classe_DEC_ML = classe_2areas(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
classe_DEC_ML#
#
sum(attr(classe_DEC_ML, "intermediates")$lq)#
# d=0.01, e=0.01#
# -5.098155#
#
# d=0.00, e=0.01#
# -5.050085#
#
classe_DEC_ML_minus_BD = sum(attr(classe_DEC_ML, "intermediates")$lq) - BD_LnL#
########################################################
########################################################
# 5. ClaSSE likelihoods and comparison to DEC#
########################################################
########################################################
#
tmprow = c(d_val, e_val, j_val, BGB_DEC_init_LnL, BD_LnL, classe_DEC_ML, classe_DEC_ML_minus_BD)#
results = rbind(results, tmprow)#
#
}}} # END FOR LOOPS
source('/drives/GDrive/__GDrive_projects/2017-06-20_27_Evolution2017_Portland/test/test_ClaSSE/ClaSSE_mods_v1.R', chdir = TRUE)
# ClaSSE helper functions#
source("/drives/GDrive/__GDrive_projects/2017-06-20_27_Evolution2017_Portland/test/test_ClaSSE/ClaSSE_mods_v1.R")
extdata_dir = np(system.file("extdata", package="BioGeoBEARS"))#
# Look at your phylogeny:#
trfn = "tree.newick"#
tr = read.tree(trfn)#
tr#
plot(tr)#
title("Example phylogeny")#
axisPhylo() # plots timescale#
#
# Look your geography data at the tips:#
geogfn = "geog.data"#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Set the maximum number of areas any species may occupy; this cannot be larger #
# than the number of areas you set up, but it can be smaller.#
max_range_size = 2#
########################################################
# BIG LOOP THROUGH d, e, j#
########################################################
dvals = c(0, 0.01, 0.05, 0.1, 0.3, 1, 3, 5)#
evals = c(0, 0.01, 0.05, 0.1, 0.3, 1, 3, 5)#
jvals = c(0, 0.01, 0.05, 0.1, 0.3, 1, 2.99)#
results = NULL#
for (d_val in dvals) {#
for (e_val in evals) {#
for (j_val in jvals) {#
#
########################################################
# Run DEC#
########################################################
#
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$force_sparse=FALSE    # sparse=FALSE causes pathology & isn't much faster at this scale#
BioGeoBEARS_run_object$speedup=TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$calc_ancprobs=TRUE    # get ancestral states from optim run#
# Input the maximum range size#
BioGeoBEARS_run_object$max_range_size = max_range_size#
# Multicore processing if desired#
BioGeoBEARS_run_object$num_cores_to_use=1#
BioGeoBEARS_run_object$force_sparse=FALSE#
#
# Give BioGeoBEARS the location of the geography text file#
BioGeoBEARS_run_object$geogfn = geogfn#
#
# Give BioGeoBEARS the location of the phylogeny Newick file#
BioGeoBEARS_run_object$trfn = trfn#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE#
#
# Set up DEC model#
# (nothing to do; defaults)#
#
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.#
BioGeoBEARS_run_object#
#
# This contains the model object#
BioGeoBEARS_run_object$BioGeoBEARS_model_object#
#
# This table contains the parameters of the model #
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table#
#
# Run this to check inputs. Read the error messages if you get them!#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Set the initial values for the "d" and "e" parameters#
dstart = d_val#
estart = e_val#
jstart = j_val#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","min"] = 0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","max"] = 5#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","min"] = 0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","max"] = 5#
# Do the likelihood calculation under these set parameters#
# (this is just 1 likelihood calculation, not an ML search)#
BGB_DEC_init_LnL = bears_optim_run(BioGeoBEARS_run_object, skip_optim=TRUE)#
BGB_DEC_init_LnL#
########################################################
########################################################
# 2. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
library(ape)#
trfn = "tree.newick"#
tr = read.tree(trfn)#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
birthRate = 0.22222222222222222222222222222222222222222222#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
########################################################
########################################################
# 3. Set up of equivalent ClaSSE model for DEC, starting values#
########################################################
########################################################
###################################################
# Set up states for ClaSSE to match DEC states#
###################################################
#
# States in the ClaSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
states = c(2, 2, 2, 3)#
names(states) = tr$tip.label#
states#
# Proportion of species in each state#
# (Let's assume we have all species)#
sampling.f = c(1,1,1,1)#
#
# Number of states#
k = 4#
#
# Make the ClaSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
classe_2areas = make.classe(tree=tr, states=states, k=4, sampling.f=sampling.f, strict=FALSE)#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
classe_2areas#
###################################################
# Set up parameters for ClaSSE to match DEC#
###################################################
# The names of the parameters:#
param_names = argnames(classe_2areas)#
#
# Most parameters will be zero#
classe_params = rep(0, times=length(param_names))#
names(classe_params) = param_names#
#
# All extinction rates are the same (state-independent)#
# Here, deathRate is 0 for all states#
classe_params[grepl(pattern="mu", x=param_names)] = deathRate#
#
# Transition rates are mostly 0, except as specified#
# by DEC anagenesis model#
d = d_val#
e = e_val#
classe_params[grepl(pattern="q", x=param_names)] = 0#
classe_params[param_names == "q21"] = e#
classe_params[param_names == "q31"] = e#
classe_params[param_names == "q24"] = d#
classe_params[param_names == "q34"] = d#
classe_params[param_names == "q42"] = e#
classe_params[param_names == "q43"] = e#
classe_params#
# The birthRate (lambda) is state-independent.  However, #
# only certain cladogenesis scenarios are allowed under DEC.#
##
# Disallowed cladogenesis scenarios have a rate of 0.#
##
# If there is more than one cladogenesis scenario conditional #
# on a certain ancestor, DEC assigns each a weight of 1, and #
# then divides by the sum of the weights. I.e., if there are#
# six possible cladogenetic range-inheritance events, they #
# each get a conditional probability of 1/6.#
# #
# To translate to ClaSSE, if the speciation rate for a lineage #
# in a certain state is lambda, then the rate of each individual #
# allowed scenario would be lambda * 1/6#
# #
y_val = (3-j_val)/3#
total_of_weights = y_val + j_val + j_val#
yprob = y_val / total_of_weights#
jprob = j_val / total_of_weights#
# Specifying the nonzero lambdas#
# Null range cannot speciate (doesn't seem to matter anyway,#
# as "null" cannot be an ancestor anyway)#
classe_params[param_names=="lambda111"] = birthRate#
#
# Narrow sympatry (ancestor A or B; rangesize of 1 area)#
classe_params[param_names=="lambda222"] = yprob * birthRate#
classe_params[param_names=="lambda333"] = yprob * birthRate#
#
# Jump dispersal speciation#
classe_params[param_names=="lambda223"] = jprob * birthRate#
classe_params[param_names=="lambda323"] = jprob * birthRate#
#
# Subset sympatry for state AB#
classe_params[param_names=="lambda424"] = 1/6 * birthRate#
classe_params[param_names=="lambda434"] = 1/6 * birthRate#
#
# Vicariance for state AB#
classe_params[param_names=="lambda423"] = 1/6 * birthRate#
#
classe_params_DEC = classe_params#
# Note: Under ClaSSE, these rates are implicitly assigned#
# to the branch rotations:#
##
# lambda424 is automatically also assigned to lambda442#
# lambda434 is automatically also assigned to lambda443#
# lambda423 is automatically also assigned to lambda432#
# #
# Note that this symmetry assumption would exclude modeling#
# of directional bias in founder-event speciation events#
#
# Calculate the ClaSSE likelihood under these parameters#
# Note that decision about the likelihood of the root states effects the LnL#
res1 = classe_2areas(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2 = classe_2areas(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.1,0.2,0.3,0.4)#
res3 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.0,1/3,1/3,1/3)#
res4 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25,0.25,0.25,0.25)#
res5 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
#
LnLs = rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5)#
print(LnLs)#
#
# You should get:#
# d=0.01, e=0.01#
# LnLs1 -6.889914 -5.098155#
# LnLs2 -8.835824 -5.098155#
# LnLs3 -8.276209 -5.098155#
# LnLs4 -8.499352 -5.098155#
# LnLs5 -8.835824 -5.098155#
#
# d=0.00, e=0.01#
# LnLs1 -6.842303 -5.050085#
# LnLs2 -8.788213 -5.050085#
# LnLs3 -8.228597 -5.050085#
# LnLs4 -8.451741 -5.050085#
# LnLs5 -8.788213 -5.050085#
# Calculate the likelihood under these parameters#
res1 = classe_2areas(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = classe_2areas(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.1,0.2,0.3,0.4)#
res3 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.0,1/3,1/3,1/3)#
res4 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25,0.25,0.25,0.25)#
res5 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
#
LnLs = rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5)#
print(LnLs)#
#
# You should get:#
# d=0.01, e=0.01#
# LnLs1  -9.087139 -5.098155#
# LnLs2 -10.473433 -5.098155#
# LnLs3 -10.003430 -5.098155#
# LnLs4 -10.185751 -5.098155#
# LnLs5 -10.473433 -5.098155#
#
# d=0.00, e=0.01#
# LnLs1  -9.039527 -5.050085#
# LnLs2 -10.425822 -5.050085#
# LnLs3  -9.955818 -5.050085#
# LnLs4 -10.138140 -5.050085#
# LnLs5 -10.425822 -5.050085#
#
classe_DEC_ML = classe_2areas(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
classe_DEC_ML#
#
sum(attr(classe_DEC_ML, "intermediates")$lq)#
# d=0.01, e=0.01#
# -5.098155#
#
# d=0.00, e=0.01#
# -5.050085#
#
classe_DEC_ML_minus_BD = sum(attr(classe_DEC_ML, "intermediates")$lq) - BD_LnL#
########################################################
########################################################
# 5. ClaSSE likelihoods and comparison to DEC#
########################################################
########################################################
#
tmprow = c(d_val, e_val, j_val, BGB_DEC_init_LnL, BD_LnL, classe_DEC_ML, classe_DEC_ML_minus_BD)#
results = rbind(results, tmprow)#
#
}}} # END FOR LOOPS
# Collate results table#
results#
results2 = as.data.frame(results, row.names=NULL)#
names(results2) = c("d_val", "e_val", "j_val", "BGB_DEC_init_LnL", "BD_LnL", "classe_DEC_ML", "classe_DEC_ML_minus_BD")#
numrows = nrow(results2)#
rownames_txt = paste(rep("d", numrows), results2$d_val, rep("e", numrows), results2$e_val, rep("j", numrows), results2$j_val, sep="_")#
rownames(results2) = rownames_txt#
results2#
lm_res = lm(formula=classe_DEC_ML_minus_BD~BGB_DEC_init_LnL, data=results2)#
summary(lm_res)#
slope_val1 = round(summary(lm_res)$coefficients[2,"Estimate"], 4)#
rsq_val1 = round(summary(lm_res)$r.squared, 4)#
stats_txt1 = paste("slope=", slope_val1, "\nR-squared=", rsq_val1, sep="")
high_LnL_TF = ( (results2$classe_DEC_ML_minus_BD > -15) + (results2$BGB_DEC_init_LnL > -15) ) == 2#
lm_res2 = lm(formula=classe_DEC_ML_minus_BD[high_LnL_TF]~BGB_DEC_init_LnL[high_LnL_TF], data=results2)#
summary(lm_res2)#
slope_val2 = round(summary(lm_res2)$coefficients[2,"Estimate"], 4)#
rsq_val2 = round(summary(lm_res2)$r.squared, 4)#
stats_txt2 = paste("slope=", slope_val2, "\nR-squared=", rsq_val2, sep="")#
# Symbols#
symbol_vals = rep("d", numrows)#
symbol_vals[results2$e_val > 0] = "e"#
symbol_vals[results2$j_val > 0] = "j"#
#
d_TF = symbol_vals == "d"#
e_TF = symbol_vals == "e"#
j_TF = symbol_vals == "j"#
#
col_vals = rep("black", length(d_TF))#
col_vals[d_TF] = "blue"#
col_vals[e_TF] = "grey25"#
col_vals[j_TF] = "darkgreen"#
# Start plot#
pdffn = "compare_many_LnLs_DEC_vs_claSSE_2plots_v2.pdf"#
pdf(file=pdffn, height=11, width=5)#
par(mfrow=c(2,1))#
plot(0, 0, xlab="data LnL under BioGeoBEARS DEC-e, DEC, or DEC+J", ylab="data LnL under claSSE, minus Yule LnL", xlim=c(-65,0), ylim=c(-65,0), pch=symbol_vals, col="white")#
title("BioGeoBEARS log-likelihoods vs.\nclaSSE log-likelihoods (all)")#
text(x=-60, y=-10, labels=stats_txt1, adj=c(0,0))#
#
# Plot DEC+Js#
# (d>0, e>0, j>0)#
points(results2$BGB_DEC_init_LnL[j_TF], results2$classe_DEC_ML_minus_BD[j_TF], pch=symbol_vals[j_TF], col=col_vals[j_TF])#
#
# Plot DECs (d>0, e>0, j=0)#
points(results2$BGB_DEC_init_LnL[e_TF], results2$classe_DEC_ML_minus_BD[e_TF], pch=symbol_vals[e_TF], col=col_vals[e_TF])#
#
# Plot DEC-e's (d>0, e=0, j=0)#
points(results2$BGB_DEC_init_LnL[d_TF], results2$classe_DEC_ML_minus_BD[d_TF], pch=symbol_vals[d_TF], col=col_vals[d_TF])#
# Start plot#
plot(0, 0, xlab="data LnL under BioGeoBEARS DEC-e, DEC, or DEC+J", ylab="data LnL under claSSE, minus Yule LnL", xlim=c(-17.5,0), ylim=c(-17.5,0), pch=symbol_vals, col="white")#
title("BioGeoBEARS log-likelihoods vs.\nclaSSE log-likelihoods (LnL > -15)")#
text(x=-16, y=-3, labels=stats_txt2, adj=c(0,0))#
# Plot DEC+Js#
# (d>0, e>0, j>0)#
TF = (j_TF + high_LnL_TF) == 2#
points(results2$BGB_DEC_init_LnL[TF], results2$classe_DEC_ML_minus_BD[TF], pch=symbol_vals[TF], col=col_vals[TF])#
#
# Plot DECs (d>0, e>0, j=0)#
TF = (e_TF + high_LnL_TF) == 2#
points(results2$BGB_DEC_init_LnL[TF], results2$classe_DEC_ML_minus_BD[TF], pch=symbol_vals[TF], col=col_vals[TF])#
#
# Plot DEC-e's (d>0, e=0, j=0)#
TF = (d_TF + high_LnL_TF) == 2#
points(results2$BGB_DEC_init_LnL[TF], results2$classe_DEC_ML_minus_BD[TF], pch=symbol_vals[TF], col=col_vals[TF])#
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)
# Start plot#
pdffn = "compare_many_LnLs_DEC_vs_claSSE_v2.pdf"#
pdf(file=pdffn, height=5, width=5)#
plot(0, 0, xlab="data LnL under BioGeoBEARS DEC-e, DEC, or DEC+J", ylab="data LnL under claSSE, minus Yule LnL", xlim=c(-65,0), ylim=c(-65,0), pch=symbol_vals, col="white")#
title("BioGeoBEARS log-likelihoods vs.\nclaSSE log-likelihoods (all)")#
text(x=-60, y=-10, labels=stats_txt1, adj=c(0,0))#
#
# Plot DEC+Js#
# (d>0, e>0, j>0)#
points(results2$BGB_DEC_init_LnL[j_TF], results2$classe_DEC_ML_minus_BD[j_TF], pch=symbol_vals[j_TF], col=col_vals[j_TF])#
#
# Plot DECs (d>0, e>0, j=0)#
points(results2$BGB_DEC_init_LnL[e_TF], results2$classe_DEC_ML_minus_BD[e_TF], pch=symbol_vals[e_TF], col=col_vals[e_TF])#
#
# Plot DEC-e's (d>0, e=0, j=0)#
points(results2$BGB_DEC_init_LnL[d_TF], results2$classe_DEC_ML_minus_BD[d_TF], pch=symbol_vals[d_TF], col=col_vals[d_TF])#
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)
# Start plot#
pdffn = "compare_many_LnLs_DEC_vs_claSSE_v3.pdf"#
pdf(file=pdffn, height=5, width=5)#
plot(0, 0, xlab="data LnL under BioGeoBEARS DEC-e, DEC, or DEC+J", ylab="data LnL under claSSE, minus Yule LnL", xlim=c(-65,0), ylim=c(-65,0), pch=symbol_vals, col="white")#
title("BioGeoBEARS log-likelihoods vs.\nclaSSE log-likelihoods (all)")#
text(x=-60, y=-10, labels=stats_txt1, adj=c(0,0))#
#
# Plot DEC+Js#
# (d>0, e>0, j>0)#
points(results2$BGB_DEC_init_LnL[j_TF], results2$classe_DEC_ML_minus_BD[j_TF], pch=symbol_vals[j_TF], col=col_vals[j_TF])#
#
# Plot DECs (d>0, e>0, j=0)#
points(results2$BGB_DEC_init_LnL[e_TF], results2$classe_DEC_ML_minus_BD[e_TF], pch=symbol_vals[e_TF], col=col_vals[e_TF])#
#
# Plot DEC-e's (d>0, e=0, j=0)#
points(results2$BGB_DEC_init_LnL[d_TF], results2$classe_DEC_ML_minus_BD[d_TF], pch=symbol_vals[d_TF], col=col_vals[d_TF])#
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)
d_val = 0.1
e_val = 0.02
j_val = 0.1
d_val = 0.1#
e_val = 0.02#
j_val = 0.1
########################################################
# Run DEC#
########################################################
#
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$force_sparse=FALSE    # sparse=FALSE causes pathology & isn't much faster at this scale#
BioGeoBEARS_run_object$speedup=TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$calc_ancprobs=TRUE    # get ancestral states from optim run#
# Input the maximum range size#
BioGeoBEARS_run_object$max_range_size = max_range_size#
# Multicore processing if desired#
BioGeoBEARS_run_object$num_cores_to_use=1#
BioGeoBEARS_run_object$force_sparse=FALSE#
#
# Give BioGeoBEARS the location of the geography text file#
BioGeoBEARS_run_object$geogfn = geogfn#
#
# Give BioGeoBEARS the location of the phylogeny Newick file#
BioGeoBEARS_run_object$trfn = trfn#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE#
#
# Set up DEC model#
# (nothing to do; defaults)#
#
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.#
BioGeoBEARS_run_object#
#
# This contains the model object#
BioGeoBEARS_run_object$BioGeoBEARS_model_object#
#
# This table contains the parameters of the model #
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table#
#
# Run this to check inputs. Read the error messages if you get them!#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Set the initial values for the "d" and "e" parameters#
dstart = d_val#
estart = e_val#
jstart = j_val#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","min"] = 0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","max"] = 5#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","min"] = 0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","max"] = 5#
# Do the likelihood calculation under these set parameters#
# (this is just 1 likelihood calculation, not an ML search)#
BGB_DEC_init_LnL = bears_optim_run(BioGeoBEARS_run_object, skip_optim=TRUE)#
BGB_DEC_init_LnL
library(ape)#
trfn = "tree.newick"#
tr = read.tree(trfn)#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2
birthRate
BD_LnL = -1 * BD$dev / 2#
BD_LnL
deathRate
states = c(2, 2, 2, 3)#
names(states) = tr$tip.label#
states#
# Proportion of species in each state#
# (Let's assume we have all species)#
sampling.f = c(1,1,1,1)#
#
# Number of states#
k = 4#
#
# Make the ClaSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
classe_2areas = make.classe(tree=tr, states=states, k=4, sampling.f=sampling.f, strict=FALSE)#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
classe_2areas#
###################################################
# Set up parameters for ClaSSE to match DEC#
###################################################
# The names of the parameters:#
param_names = argnames(classe_2areas)#
#
# Most parameters will be zero#
classe_params = rep(0, times=length(param_names))#
names(classe_params) = param_names#
#
# All extinction rates are the same (state-independent)#
# Here, deathRate is 0 for all states#
classe_params[grepl(pattern="mu", x=param_names)] = deathRate#
#
# Transition rates are mostly 0, except as specified#
# by DEC anagenesis model#
d = d_val#
e = e_val#
classe_params[grepl(pattern="q", x=param_names)] = 0#
classe_params[param_names == "q21"] = e#
classe_params[param_names == "q31"] = e#
classe_params[param_names == "q24"] = d#
classe_params[param_names == "q34"] = d#
classe_params[param_names == "q42"] = e#
classe_params[param_names == "q43"] = e#
classe_params#
# The birthRate (lambda) is state-independent.  However, #
# only certain cladogenesis scenarios are allowed under DEC.#
##
# Disallowed cladogenesis scenarios have a rate of 0.#
##
# If there is more than one cladogenesis scenario conditional #
# on a certain ancestor, DEC assigns each a weight of 1, and #
# then divides by the sum of the weights. I.e., if there are#
# six possible cladogenetic range-inheritance events, they #
# each get a conditional probability of 1/6.#
# #
# To translate to ClaSSE, if the speciation rate for a lineage #
# in a certain state is lambda, then the rate of each individual #
# allowed scenario would be lambda * 1/6#
# #
y_val = (3-j_val)/3#
total_of_weights = y_val + j_val + j_val#
yprob = y_val / total_of_weights#
jprob = j_val / total_of_weights#
# Specifying the nonzero lambdas#
# Null range cannot speciate (doesn't seem to matter anyway,#
# as "null" cannot be an ancestor anyway)#
classe_params[param_names=="lambda111"] = birthRate#
#
# Narrow sympatry (ancestor A or B; rangesize of 1 area)#
classe_params[param_names=="lambda222"] = yprob * birthRate#
classe_params[param_names=="lambda333"] = yprob * birthRate#
#
# Jump dispersal speciation#
classe_params[param_names=="lambda223"] = jprob * birthRate#
classe_params[param_names=="lambda323"] = jprob * birthRate#
#
# Subset sympatry for state AB#
classe_params[param_names=="lambda424"] = 1/6 * birthRate#
classe_params[param_names=="lambda434"] = 1/6 * birthRate#
#
# Vicariance for state AB#
classe_params[param_names=="lambda423"] = 1/6 * birthRate#
#
classe_params_DEC = classe_params#
# Note: Under ClaSSE, these rates are implicitly assigned#
# to the branch rotations:#
##
# lambda424 is automatically also assigned to lambda442#
# lambda434 is automatically also assigned to lambda443#
# lambda423 is automatically also assigned to lambda432#
# #
# Note that this symmetry assumption would exclude modeling#
# of directional bias in founder-event speciation events#
#
# Calculate the ClaSSE likelihood under these parameters#
# Note that decision about the likelihood of the root states effects the LnL#
res1 = classe_2areas(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2 = classe_2areas(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.1,0.2,0.3,0.4)#
res3 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.0,1/3,1/3,1/3)#
res4 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25,0.25,0.25,0.25)#
res5 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
#
LnLs = rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5)#
print(LnLs)
res1 = classe_2areas(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = classe_2areas(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.1,0.2,0.3,0.4)#
res3 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.0,1/3,1/3,1/3)#
res4 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25,0.25,0.25,0.25)#
res5 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
#
LnLs = rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5)#
print(LnLs)#
#
# You should get:#
# d=0.01, e=0.01#
# LnLs1  -9.087139 -5.098155#
# LnLs2 -10.473433 -5.098155#
# LnLs3 -10.003430 -5.098155#
# LnLs4 -10.185751 -5.098155#
# LnLs5 -10.473433 -5.098155#
#
# d=0.00, e=0.01#
# LnLs1  -9.039527 -5.050085#
# LnLs2 -10.425822 -5.050085#
# LnLs3  -9.955818 -5.050085#
# LnLs4 -10.138140 -5.050085#
# LnLs5 -10.425822 -5.050085#
#
classe_DEC_ML = classe_2areas(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
classe_DEC_ML
classe_DEC_ML_minus_BD = sum(attr(classe_DEC_ML, "intermediates")$lq) - BD_LnL
sum(attr(classe_DEC_ML, "intermediates")$lq)
BD_LnL
tmprow = c(d_val, e_val, j_val, BGB_DEC_init_LnL, BD_LnL, classe_DEC_ML, classe_DEC_ML_minus_BD)
tmprow
classe_DEC_ML = classe_2areas(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
classe_DEC_ML#
#
sum(attr(classe_DEC_ML, "intermediates")$lq)#
# d=0.01, e=0.01#
# -5.098155#
#
# d=0.00, e=0.01#
# -5.050085#
#
classe_DEC_ML_minus_BD = sum(attr(classe_DEC_ML, "intermediates")$lq) - BD_LnL#
########################################################
########################################################
# 5. ClaSSE likelihoods and comparison to DEC#
########################################################
########################################################
#
tmprow = c(d_val, e_val, j_val, BGB_DEC_init_LnL, BD_LnL, classe_DEC_ML, classe_DEC_ML_minus_BD)
tmprow
classe_DEC_ML
classe_DEC_ML = classe_2areas(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
classe_DEC_ML#
#
sum(attr(classe_DEC_ML, "intermediates")$lq)
classe_DEC_ML = classe_2areas(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
classe_DEC_ML#
#
sum(attr(classe_DEC_ML, "intermediates")$lq)#
# d=0.01, e=0.01#
# -5.098155#
#
# d=0.00, e=0.01#
# -5.050085#
#
classe_DEC_ML_minus_BD = sum(attr(classe_DEC_ML, "intermediates")$lq) - BD_LnL#
########################################################
########################################################
# 5. ClaSSE likelihoods and comparison to DEC#
########################################################
########################################################
#
tmprow = c(d_val, e_val, j_val, BGB_DEC_init_LnL, BD_LnL, classe_DEC_ML, classe_DEC_ML_minus_BD)
tmprow
sum(attr(classe_DEC_ML, "intermediates")$lq)
d_val = 0.1#
e_val = 0.02#
j_val = 0.0
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$force_sparse=FALSE    # sparse=FALSE causes pathology & isn't much faster at this scale#
BioGeoBEARS_run_object$speedup=TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$calc_ancprobs=TRUE    # get ancestral states from optim run#
# Input the maximum range size#
BioGeoBEARS_run_object$max_range_size = max_range_size#
# Multicore processing if desired#
BioGeoBEARS_run_object$num_cores_to_use=1#
BioGeoBEARS_run_object$force_sparse=FALSE#
#
# Give BioGeoBEARS the location of the geography text file#
BioGeoBEARS_run_object$geogfn = geogfn#
#
# Give BioGeoBEARS the location of the phylogeny Newick file#
BioGeoBEARS_run_object$trfn = trfn#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE#
#
# Set up DEC model#
# (nothing to do; defaults)#
#
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.#
BioGeoBEARS_run_object#
#
# This contains the model object#
BioGeoBEARS_run_object$BioGeoBEARS_model_object#
#
# This table contains the parameters of the model #
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table#
#
# Run this to check inputs. Read the error messages if you get them!#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Set the initial values for the "d" and "e" parameters#
dstart = d_val#
estart = e_val#
jstart = j_val#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","min"] = 0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","max"] = 5#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","min"] = 0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","max"] = 5#
# Do the likelihood calculation under these set parameters#
# (this is just 1 likelihood calculation, not an ML search)#
BGB_DEC_init_LnL = bears_optim_run(BioGeoBEARS_run_object, skip_optim=TRUE)#
BGB_DEC_init_LnL#
########################################################
########################################################
# 2. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
library(ape)#
trfn = "tree.newick"#
tr = read.tree(trfn)#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#birthRate = 0.22222222222222222222222222222222222222222222#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
########################################################
########################################################
# 3. Set up of equivalent ClaSSE model for DEC, starting values#
########################################################
########################################################
###################################################
# Set up states for ClaSSE to match DEC states#
###################################################
#
# States in the ClaSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
states = c(2, 2, 2, 3)#
names(states) = tr$tip.label#
states#
# Proportion of species in each state#
# (Let's assume we have all species)#
sampling.f = c(1,1,1,1)#
#
# Number of states#
k = 4#
#
# Make the ClaSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
classe_2areas = make.classe(tree=tr, states=states, k=4, sampling.f=sampling.f, strict=FALSE)#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
classe_2areas#
###################################################
# Set up parameters for ClaSSE to match DEC#
###################################################
# The names of the parameters:#
param_names = argnames(classe_2areas)#
#
# Most parameters will be zero#
classe_params = rep(0, times=length(param_names))#
names(classe_params) = param_names#
#
# All extinction rates are the same (state-independent)#
# Here, deathRate is 0 for all states#
classe_params[grepl(pattern="mu", x=param_names)] = deathRate#
#
# Transition rates are mostly 0, except as specified#
# by DEC anagenesis model#
d = d_val#
e = e_val#
classe_params[grepl(pattern="q", x=param_names)] = 0#
classe_params[param_names == "q21"] = e#
classe_params[param_names == "q31"] = e#
classe_params[param_names == "q24"] = d#
classe_params[param_names == "q34"] = d#
classe_params[param_names == "q42"] = e#
classe_params[param_names == "q43"] = e#
classe_params#
# The birthRate (lambda) is state-independent.  However, #
# only certain cladogenesis scenarios are allowed under DEC.#
##
# Disallowed cladogenesis scenarios have a rate of 0.#
##
# If there is more than one cladogenesis scenario conditional #
# on a certain ancestor, DEC assigns each a weight of 1, and #
# then divides by the sum of the weights. I.e., if there are#
# six possible cladogenetic range-inheritance events, they #
# each get a conditional probability of 1/6.#
# #
# To translate to ClaSSE, if the speciation rate for a lineage #
# in a certain state is lambda, then the rate of each individual #
# allowed scenario would be lambda * 1/6#
# #
y_val = (3-j_val)/3#
total_of_weights = y_val + j_val + j_val#
yprob = y_val / total_of_weights#
jprob = j_val / total_of_weights#
# Specifying the nonzero lambdas#
# Null range cannot speciate (doesn't seem to matter anyway,#
# as "null" cannot be an ancestor anyway)#
classe_params[param_names=="lambda111"] = birthRate#
#
# Narrow sympatry (ancestor A or B; rangesize of 1 area)#
classe_params[param_names=="lambda222"] = yprob * birthRate#
classe_params[param_names=="lambda333"] = yprob * birthRate#
#
# Jump dispersal speciation#
classe_params[param_names=="lambda223"] = jprob * birthRate#
classe_params[param_names=="lambda323"] = jprob * birthRate#
#
# Subset sympatry for state AB#
classe_params[param_names=="lambda424"] = 1/6 * birthRate#
classe_params[param_names=="lambda434"] = 1/6 * birthRate#
#
# Vicariance for state AB#
classe_params[param_names=="lambda423"] = 1/6 * birthRate#
#
classe_params_DEC = classe_params#
# Note: Under ClaSSE, these rates are implicitly assigned#
# to the branch rotations:#
##
# lambda424 is automatically also assigned to lambda442#
# lambda434 is automatically also assigned to lambda443#
# lambda423 is automatically also assigned to lambda432#
# #
# Note that this symmetry assumption would exclude modeling#
# of directional bias in founder-event speciation events#
#
# Calculate the ClaSSE likelihood under these parameters#
# Note that decision about the likelihood of the root states effects the LnL#
res1 = classe_2areas(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2 = classe_2areas(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.1,0.2,0.3,0.4)#
res3 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.0,1/3,1/3,1/3)#
res4 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25,0.25,0.25,0.25)#
res5 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
#
LnLs = rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5)#
print(LnLs)#
#
# You should get:#
# d=0.01, e=0.01#
# LnLs1 -6.889914 -5.098155#
# LnLs2 -8.835824 -5.098155#
# LnLs3 -8.276209 -5.098155#
# LnLs4 -8.499352 -5.098155#
# LnLs5 -8.835824 -5.098155#
#
# d=0.00, e=0.01#
# LnLs1 -6.842303 -5.050085#
# LnLs2 -8.788213 -5.050085#
# LnLs3 -8.228597 -5.050085#
# LnLs4 -8.451741 -5.050085#
# LnLs5 -8.788213 -5.050085#
# Calculate the likelihood under these parameters#
res1 = classe_2areas(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = classe_2areas(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.1,0.2,0.3,0.4)#
res3 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.0,1/3,1/3,1/3)#
res4 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25,0.25,0.25,0.25)#
res5 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
#
LnLs = rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5)#
print(LnLs)#
#
# You should get:#
# d=0.01, e=0.01#
# LnLs1  -9.087139 -5.098155#
# LnLs2 -10.473433 -5.098155#
# LnLs3 -10.003430 -5.098155#
# LnLs4 -10.185751 -5.098155#
# LnLs5 -10.473433 -5.098155#
#
# d=0.00, e=0.01#
# LnLs1  -9.039527 -5.050085#
# LnLs2 -10.425822 -5.050085#
# LnLs3  -9.955818 -5.050085#
# LnLs4 -10.138140 -5.050085#
# LnLs5 -10.425822 -5.050085#
#
classe_DEC_ML = classe_2areas(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
classe_DEC_ML#
#
sum(attr(classe_DEC_ML, "intermediates")$lq)#
# d=0.01, e=0.01#
# -5.098155#
#
# d=0.00, e=0.01#
# -5.050085#
#
classe_DEC_ML_minus_BD = sum(attr(classe_DEC_ML, "intermediates")$lq) - BD_LnL#
########################################################
########################################################
# 5. ClaSSE likelihoods and comparison to DEC#
########################################################
########################################################
#
tmprow = c(d_val, e_val, j_val, BGB_DEC_init_LnL, BD_LnL, classe_DEC_ML, classe_DEC_ML_minus_BD)
tmprow
sum(attr(classe_DEC_ML, "intermediates")$lq)
d_val = 0.1e_val = 0.0j_val = 0.0
########################################################
# Run DEC#
########################################################
#
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$force_sparse=FALSE    # sparse=FALSE causes pathology & isn't much faster at this scale#
BioGeoBEARS_run_object$speedup=TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$calc_ancprobs=TRUE    # get ancestral states from optim run#
# Input the maximum range size#
BioGeoBEARS_run_object$max_range_size = max_range_size#
# Multicore processing if desired#
BioGeoBEARS_run_object$num_cores_to_use=1#
BioGeoBEARS_run_object$force_sparse=FALSE#
#
# Give BioGeoBEARS the location of the geography text file#
BioGeoBEARS_run_object$geogfn = geogfn#
#
# Give BioGeoBEARS the location of the phylogeny Newick file#
BioGeoBEARS_run_object$trfn = trfn#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE#
#
# Set up DEC model#
# (nothing to do; defaults)#
#
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.#
BioGeoBEARS_run_object#
#
# This contains the model object#
BioGeoBEARS_run_object$BioGeoBEARS_model_object#
#
# This table contains the parameters of the model #
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table#
#
# Run this to check inputs. Read the error messages if you get them!#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Set the initial values for the "d" and "e" parameters#
dstart = d_val#
estart = e_val#
jstart = j_val#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","min"] = 0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","max"] = 5#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","min"] = 0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","max"] = 5#
# Do the likelihood calculation under these set parameters#
# (this is just 1 likelihood calculation, not an ML search)#
BGB_DEC_init_LnL = bears_optim_run(BioGeoBEARS_run_object, skip_optim=TRUE)#
BGB_DEC_init_LnL#
########################################################
########################################################
# 2. Calculation of tree likelihood under a Yule process#
########################################################
########################################################
library(ape)#
trfn = "tree.newick"#
tr = read.tree(trfn)#
#
# Get the ML estimates of birthRate (speciation rate) #
# and deathRate (extinction rate)#
# ...using ape::birthdeath#
BD =  birthdeath(tr)#
BD#
names(BD)#
#
# Calculate the birthRate and deathRate from the outputs#
x1 = unname(BD$para["d/b"])#
x2 = unname(BD$para["b-d"])#
deathRate = (x2*x1) / (1-x1)#
birthRate = deathRate+x2#
c(birthRate, deathRate)#
#birthRate = 0.22222222222222222222222222222222222222222222#
#
# You should get:#
# c(birthRate, deathRate)#
# [1] 0.2222222 0.0000000#
#
# Get the log-likelihood of the tree under the ML parameters#
# Convert the deviance to likelihood#
BD_LnL = -1 * BD$dev / 2#
BD_LnL#
########################################################
########################################################
# 3. Set up of equivalent ClaSSE model for DEC, starting values#
########################################################
########################################################
###################################################
# Set up states for ClaSSE to match DEC states#
###################################################
#
# States in the ClaSSE model, and how they correspond#
# to the geographic ranges in DEC#
# #
# ====================#
# (statenum = range)#
# ====================#
# 1 = null range#
# 2 = A = Africa#
# 3 = B = Asia#
# 4 = AB = both#
# ====================#
#
# States at the tips of the tree#
# (ranges A, A, A, B)#
states = c(2, 2, 2, 3)#
names(states) = tr$tip.label#
states#
# Proportion of species in each state#
# (Let's assume we have all species)#
sampling.f = c(1,1,1,1)#
#
# Number of states#
k = 4#
#
# Make the ClaSSE likelihood function. #
# (strict=FALSE means that some states in the state space can be absent from the tips)#
classe_2areas = make.classe(tree=tr, states=states, k=4, sampling.f=sampling.f, strict=FALSE)#
# Look at all the parameters of this model!#
# lambdas = speciation rates#
# mus = extinction rates#
# qs = anagenetic transition rates#
classe_2areas#
###################################################
# Set up parameters for ClaSSE to match DEC#
###################################################
# The names of the parameters:#
param_names = argnames(classe_2areas)#
#
# Most parameters will be zero#
classe_params = rep(0, times=length(param_names))#
names(classe_params) = param_names#
#
# All extinction rates are the same (state-independent)#
# Here, deathRate is 0 for all states#
classe_params[grepl(pattern="mu", x=param_names)] = deathRate#
#
# Transition rates are mostly 0, except as specified#
# by DEC anagenesis model#
d = d_val#
e = e_val#
classe_params[grepl(pattern="q", x=param_names)] = 0#
classe_params[param_names == "q21"] = e#
classe_params[param_names == "q31"] = e#
classe_params[param_names == "q24"] = d#
classe_params[param_names == "q34"] = d#
classe_params[param_names == "q42"] = e#
classe_params[param_names == "q43"] = e#
classe_params#
# The birthRate (lambda) is state-independent.  However, #
# only certain cladogenesis scenarios are allowed under DEC.#
##
# Disallowed cladogenesis scenarios have a rate of 0.#
##
# If there is more than one cladogenesis scenario conditional #
# on a certain ancestor, DEC assigns each a weight of 1, and #
# then divides by the sum of the weights. I.e., if there are#
# six possible cladogenetic range-inheritance events, they #
# each get a conditional probability of 1/6.#
# #
# To translate to ClaSSE, if the speciation rate for a lineage #
# in a certain state is lambda, then the rate of each individual #
# allowed scenario would be lambda * 1/6#
# #
y_val = (3-j_val)/3#
total_of_weights = y_val + j_val + j_val#
yprob = y_val / total_of_weights#
jprob = j_val / total_of_weights#
# Specifying the nonzero lambdas#
# Null range cannot speciate (doesn't seem to matter anyway,#
# as "null" cannot be an ancestor anyway)#
classe_params[param_names=="lambda111"] = birthRate#
#
# Narrow sympatry (ancestor A or B; rangesize of 1 area)#
classe_params[param_names=="lambda222"] = yprob * birthRate#
classe_params[param_names=="lambda333"] = yprob * birthRate#
#
# Jump dispersal speciation#
classe_params[param_names=="lambda223"] = jprob * birthRate#
classe_params[param_names=="lambda323"] = jprob * birthRate#
#
# Subset sympatry for state AB#
classe_params[param_names=="lambda424"] = 1/6 * birthRate#
classe_params[param_names=="lambda434"] = 1/6 * birthRate#
#
# Vicariance for state AB#
classe_params[param_names=="lambda423"] = 1/6 * birthRate#
#
classe_params_DEC = classe_params#
# Note: Under ClaSSE, these rates are implicitly assigned#
# to the branch rotations:#
##
# lambda424 is automatically also assigned to lambda442#
# lambda434 is automatically also assigned to lambda443#
# lambda423 is automatically also assigned to lambda432#
# #
# Note that this symmetry assumption would exclude modeling#
# of directional bias in founder-event speciation events#
#
# Calculate the ClaSSE likelihood under these parameters#
# Note that decision about the likelihood of the root states effects the LnL#
res1 = classe_2areas(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2 = classe_2areas(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.1,0.2,0.3,0.4)#
res3 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.0,1/3,1/3,1/3)#
res4 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25,0.25,0.25,0.25)#
res5 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
#
LnLs = rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5)#
print(LnLs)#
#
# You should get:#
# d=0.01, e=0.01#
# LnLs1 -6.889914 -5.098155#
# LnLs2 -8.835824 -5.098155#
# LnLs3 -8.276209 -5.098155#
# LnLs4 -8.499352 -5.098155#
# LnLs5 -8.835824 -5.098155#
#
# d=0.00, e=0.01#
# LnLs1 -6.842303 -5.050085#
# LnLs2 -8.788213 -5.050085#
# LnLs3 -8.228597 -5.050085#
# LnLs4 -8.451741 -5.050085#
# LnLs5 -8.788213 -5.050085#
# Calculate the likelihood under these parameters#
res1 = classe_2areas(pars=classe_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = classe_2areas(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.1,0.2,0.3,0.4)#
res3 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.0,1/3,1/3,1/3)#
res4 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25,0.25,0.25,0.25)#
res5 = classe_2areas(pars=classe_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
#
LnLs = rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5)#
print(LnLs)#
#
# You should get:#
# d=0.01, e=0.01#
# LnLs1  -9.087139 -5.098155#
# LnLs2 -10.473433 -5.098155#
# LnLs3 -10.003430 -5.098155#
# LnLs4 -10.185751 -5.098155#
# LnLs5 -10.473433 -5.098155#
#
# d=0.00, e=0.01#
# LnLs1  -9.039527 -5.050085#
# LnLs2 -10.425822 -5.050085#
# LnLs3  -9.955818 -5.050085#
# LnLs4 -10.138140 -5.050085#
# LnLs5 -10.425822 -5.050085#
#
classe_DEC_ML = classe_2areas(pars=classe_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
classe_DEC_ML#
#
sum(attr(classe_DEC_ML, "intermediates")$lq)#
# d=0.01, e=0.01#
# -5.098155#
#
# d=0.00, e=0.01#
# -5.050085#
#
classe_DEC_ML_minus_BD = sum(attr(classe_DEC_ML, "intermediates")$lq) - BD_LnL#
########################################################
########################################################
# 5. ClaSSE likelihoods and comparison to DEC#
########################################################
########################################################
#
tmprow = c(d_val, e_val, j_val, BGB_DEC_init_LnL, BD_LnL, classe_DEC_ML, classe_DEC_ML_minus_BD)#
results = rbind(results, tmprow)
tmprow
sum(attr(classe_DEC_ML, "intermediates")$lq)
classe_DEC_ML
0.25^8
log(0.25^8)
log(0.25^4)
classe_DEC_ML
sum(attr(classe_DEC_ML, "intermediates")$lq)
0.25^4
log(0.01851852)
classe_2areas
ROOT.FLAT
get_classe_LnLs
2^6
