nodelabels(thermo=t(st), piecol=cols, cex=0.5)
phy2 = phy#
phy2$edge.length[c(1,4)] = c(1-phy2$edge.length[2], 1-phy2$edge.length[6])#
phy2$tip.state[1:4] = c(0, 1, 0, 1, 0)#
#
plot(phy2, label.offset=0.1)#
tiplabels(text=phy2$tip.state, tip=1:4, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik2 <- make.bisse(phy2, phy2$tip.state)#
fit2 <- find.mle(func=lik2, x.init=coef(fit), method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
parsdf = cft(adf2(matrix(coef(fit2),nrow=1))); names(parsdf)=names(coef(fit2))#
parsdf
phy
phy2 = phy#
phy2$edge.length[c(1,4)] = c(1-phy2$edge.length[2], 1-phy2$edge.length[6])#
phy2$tip.state[1:5] = c(0, 1, 0, 1, 0)
plot(phy2, label.offset=0.1)#
tiplabels(text=phy2$tip.state, tip=1:4, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik2 <- make.bisse(phy2, phy2$tip.state)#
fit2 <- find.mle(func=lik2, x.init=coef(fit), method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
parsdf = cft(adf2(matrix(coef(fit2),nrow=1))); names(parsdf)=names(coef(fit2))#
parsdf
phy2 = phy#
phy2$tip.state[1:5] = c(0, 1, 0, 1, 0)
plot(phy2, label.offset=0.1)#
tiplabels(text=phy2$tip.state, tip=1:4, col="black", bg=cols[phy2$tip.state+1])
phy2 = phy#
phy2$tip.state[1:5] = c(0, 1, 0, 1, 0)#
#
plot(phy2, label.offset=0.1)#
tiplabels(text=phy2$tip.state, tip=1:5, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)
lik2 <- make.bisse(phy2, phy2$tip.state)#
fit2 <- find.mle(func=lik2, x.init=coef(fit), method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
parsdf = cft(adf2(matrix(coef(fit2),nrow=1))); names(parsdf)=names(coef(fit2))#
parsdf
st2 <- asr.marginal(lik2, coef(fit2))#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)
states_df2 = cft(adf2(t(st2)))#
states_df2
phy2
phy2$edge.length
prt(phy2)
phy2 = phy#
phy2$tip.state[1:5] = c(0, 1, 0, 1, 0)#
phy2$edge.length[6:7] = phy2$edge.length[6:7]+1.0#
phy2$edge.length[9] = phy2$edge.length[9] - 1.0
plot(phy2)
phy2$edge.length
phy2 = phy#
phy2$tip.state[1:5] = c(0, 1, 0, 1, 0)#
phy2$edge.length[6:7] = phy2$edge.length[6:7]+1.0#
phy2$edge.length[5] = phy2$edge.length[5] - 1.0#
plot(phy2, label.offset=0.1)
plot(phy2, label.offset=0.1)#
tiplabels(text=phy2$tip.state, tip=1:5, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik2 <- make.bisse(phy2, phy2$tip.state)#
fit2 <- find.mle(func=lik2, x.init=coef(fit), method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
parsdf = cft(adf2(matrix(coef(fit2),nrow=1))); names(parsdf)=names(coef(fit2))#
parsdf
st2 <- asr.marginal(lik2, coef(fit2))#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)#
#
states_df2 = cft(adf2(t(st2)))#
states_df2
plot(phy2, label.offset=0.1)#
tiplabels(text=phy2$tip.state, tip=1:5, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik2 <- make.bisse(phy2, phy2$tip.state)#
fit2 <- find.mle(func=lik2, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
parsdf = cft(adf2(matrix(coef(fit2),nrow=1))); names(parsdf)=names(coef(fit2))#
parsdf
st2 <- asr.marginal(lik2, pars)#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)
# Gives weird result -- green nodes, blue truth#
set.seed(47) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.222222222, 0.1, 0.05)#
#
# Seems accurate#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.05, 0.1, 0.15)#
#
set.seed(59) # Rare to have a transition, but observed here#
phy <- trees(pars, "bisse", max.taxa=10, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
parsdf = cft(adf2(matrix(coef(fit),nrow=1))); names(parsdf)=names(coef(fit))#
parsdf
st <- asr.marginal(lik, coef(fit))#
states_df = cft(adf2(t(st)))#
states_df
nodelabels(thermo=t(st), piecol=cols, cex=0.5)
?plot.phylo
plot(phy, label.offset=0.05)
plot(phy, label.offset=0.5)
plot(phy, label.offset=0.5, main="Inferred history")#
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
parsdf = cft(adf2(matrix(coef(fit),nrow=1))); names(parsdf)=names(coef(fit))#
parsdf#
#
st <- asr.marginal(lik, coef(fit))#
states_df = cft(adf2(t(st)))#
states_df#
#
nodelabels(thermo=t(st), piecol=cols, cex=0.5)
set.seed(59) # Rare to have a transition, but observed here#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)
fit
names(fit)
fit$par
set.seed(59) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.222222222, 0.1, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
#
# ML on this tiny dataset is meaningless#
fit$par[1:length(fit$par)] = pars
lik
st <- asr.marginal(lik, pars)
st
set.seed(59) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.222222222, 0.03, 0.02)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
#
# ML on this tiny dataset is meaningless#
fit$par[1:length(fit$par)] = pars#
#
plot(phy, label.offset=0.1)#
tiplabels(text=phy$tip.state, tip=1:5, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
#fit2 <- find.mle(lik2, pars, method="subplex", fail.value=-1e10)#
st <- asr.marginal(lik, pars)#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)
set.seed(61) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.222222222, 0.03, 0.02)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
set.seed(63) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.222222222, 0.03, 0.02)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
set.seed(65) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.222222222, 0.03, 0.02)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
set.seed(67) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.222222222, 0.03, 0.02)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
set.seed(75) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.222222222, 0.03, 0.02)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
set.seed(75) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.222222222, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
#
# ML on this tiny dataset is meaningless#
fit$par[1:length(fit$par)] = pars
plot(phy, label.offset=0.1)#
tiplabels(text=phy$tip.state, tip=1:5, col="black", bg=cols[phy2$tip.state+1])
st <- asr.marginal(lik, pars)#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)
set.seed(75) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
#
# ML on this tiny dataset is meaningless#
fit$par[1:length(fit$par)] = pars#
#
plot(phy, label.offset=0.1)#
tiplabels(text=phy$tip.state, tip=1:5, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
#fit2 <- find.mle(lik2, pars, method="subplex", fail.value=-1e10)#
st <- asr.marginal(lik, pars)#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)
set.seed(75) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)
fit$par[1:length(fit$par)] = pars#
#
plot(phy, label.offset=0.1)#
tiplabels(text=phy$tip.state, tip=1:5, col="black", bg=cols[phy2$tip.state+1])
phy$tip.state
diversitree:::plot.history(h, phy, main="True history", cols=cols)
h
set.seed(75) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
#
# ML on this tiny dataset is meaningless#
fit$par[1:length(fit$par)] = pars#
#
plot(phy, label.offset=0.1)#
tiplabels(text=phy$tip.state, tip=1:5, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
#fit2 <- find.mle(lik2, pars, method="subplex", fail.value=-1e10)#
st <- asr.marginal(lik, pars)#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)#
#
states_df2 = cft(adf2(t(st2)))#
states_df2#
#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)
set.seed(75) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
set.seed(77) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
set.seed(79) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
set.seed(81) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
set.seed(813) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)
set.seed(8153) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
set.seed(654) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
set.seed(6534) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
#
# ML on this tiny dataset is meaningless#
fit$par[1:length(fit$par)] = pars#
#
plot(phy, label.offset=0.1)#
tiplabels(text=phy$tip.state, tip=1:5, col="black", bg=cols[phy2$tip.state+1])
phy$tip.state
plot(phy, label.offset=0.1)#
tiplabels(text=phy$tip.state, tip=names(phy$tip.state), col="black", bg=cols[phy2$tip.state+1])
*phy$tip.state
phy$tip.state
plot(phy, label.offset=0.2)#
axisPhylo()#
tiplabels(text=phy$tip.state, col="black", bg=cols[phy2$tip.state+1])
phy
prt(phy)
set.seed(6534) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.0111111111, 0.06, 0.05)#
#
phy <- trees(pars, "bisse", max.taxa=5, max.t=Inf, x0=0)[[1]]#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik <- make.bisse(phy, phy$tip.state)#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
#
# ML on this tiny dataset is meaningless#
fit$par[1:length(fit$par)] = pars#
#
plot(phy, label.offset=0.2)#
axisPhylo()#
tiplabels(text=phy$tip.state, tip=names(phy$tip.state), col="black", bg=cols[phy$tip.state+1])
tiplabels(text=phy$tip.state, tip=1:5, col="black", bg=cols[phy$tip.state+1])
st <- asr.marginal(lik, pars)#
nodelabels(thermo=t(st), piecol=cols, cex=0.5)#
t(st)
st <- asr.marginal(lik, pars)#
nodelabels(thermo=t(st), piecol=cols, cex=0.5)#
t(st)#
#
states_df = cft(adf2(t(st)))#
states_df#
#
nodelabels(thermo=t(st), piecol=cols, cex=0.5)
write.tree(phy, file="")
pht$tip.data
phy$tip.data
phy$tip.state
pars
/GitHub/PhyBEARS.jl/test/simtree_5taxa_SSE
t(st)
lik
lik(pars)
make.bisse
make.classe
lik(pars)
lik(pars, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)
attr(reslnls,"intermediates")$lq
reslnls = lik(pars, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
# -15.63256#
attr(reslnls,"intermediates")$lq
sum(attr(reslnls,"intermediates")$lq)
pars
sum(attr(reslnls,"intermediates")$lq)
reslnls = lik(pars, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
# -15.63256#
sum(attr(reslnls,"intermediates")$lq)
reslnls = lik(pars, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
# -15.63256#
sum(attr(reslnls,"intermediates")$lq)#
# -12.87511#
reslnls = lik(pars, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
# -12.87511#
sum(attr(reslnls,"intermediates")$lq)
library(BioGeoBEARS)#
library(diversitree)#
source("/GitHub/PhyBEARS.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/PhyBEARS.jl/Rsrc/ClaSSE_functions_v3.R")#
#
## Start with a simple tree evolved under a BiSSE with all rates#
## asymmetric:#
# lambda0, lambda1, mu0, mu1, q01, q10#
#
# Gives weird result -- green nodes, blue truth#
set.seed(47) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.05, 0.1, 0.15)#
bisse_params = pars#
birthRate = pars[1]#
deathRate = pars[3]#
#
set.seed(48) # Rare to have a transition, but observed here#
phy <- trees(pars, "bisse", max.taxa=4, max.t=Inf, x0=0)[[1]]#
write.tree(phy, file="")#
#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik <- make.bisse(phy, phy$tip.state)#
phy$tip.state#
#
bisse_2areas = lik#
#fit <- find.mle(lik, pars, method="subplex")#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
coef(fit)#
st <- asr.marginal(lik, coef(fit))#
nodelabels(thermo=t(st), piecol=cols, cex=0.5)#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
# Res1t is BiSSE default#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)
res1t
res5t
LnLst5
LnLst2
LnLst2["LnLs5t",]
LnLst2["LnLs5t","branch_LnL"]
LnLst2["LnLs5t","ttl_LnL"]
LnLst2["LnLs1t","branch_LnL"]
LnLst2["LnLs1t","ttl_LnL"]
LnLst2["LnLs1","ttl_LnL"]
LnLst2["LnLs1","branch_LnL"]
LnLst2["LnLs1","branch_LnL"]#
LnLst2["LnLs1","ttl_LnL"]
-6.670978+-0.7933087125199055
LnLst2["LnLs1","branch_LnL"]#
LnLst2["LnLs1t","ttl_LnL"]
LnLs1t
LnLs1
reLnLs1
LnLs1
LnLs1t
-9.574440+-2.9034623
EsDs = t(attr(res1t,"intermediates")$init)#
sum(log(rowSums(EsDs[,3:4])))#
attr(res1t,"intermediates")$lq
sum(attr(res1t,"intermediates")$lq)
res1t
sum(log(rowSums(EsDs[,3:4])))#
attr(res1t,"intermediates")$lq
EsDs = t(attr(res1t,"intermediates")$init)#
sum(log(rowSums(EsDs[,3:4])))#
attr(res1t,"intermediates")$lq#
sum(attr(res1t,"intermediates")$lq)#
sum(log(rowSums(EsDs[,3:4]))) + sum(attr(res1t,"intermediates")$lq)
########################################################
# Look at find.mle#
########################################################
methods("find.mle")#
diversitree:::find.mle.default#
diversitree:::find.mle.dtlik#
diversitree:::find.mle.mixed#
diversitree:::do.mle.search#
# change to create some ambiguity#
#
phy2 = phy#
phy2$edge.length[c(1,4)] = c(1-phy2$edge.length[2], 1-phy2$edge.length[6])#
phy2$tip.state[1:4] = c(0, 1, 0, 1)#
#
plot(phy2, label.offset=0.1)#
tiplabels(text=phy2$tip.state, tip=1:4, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik2 <- make.bisse(phy2, phy2$tip.state)#
fit2 <- find.mle(func=lik2, x.init=coef(fit), method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
coef(fit2 )#
#fit2 <- find.mle(lik2, pars, method="subplex", fail.value=-1e10)#
st2 <- asr.marginal(lik2, coef(fit2))#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)
pars
st
t(st)
st2
LIK2
lik2
names(lik2)
str(lik2)
attributes(lik2)
attr(lik2)
attr(lik2, "dtlik")
st2 <- asr.marginal(lik2, pars)
st2
coef(fit2)
pars
st2 <- asr.marginal(lik2, coef(fit2))#
names(pars) = names(coef(fit2))#
st2 <- asr.marginal(lik2, pars)
st2
pars
st2
pars$mu0 = 0#
pars$mu1 = 0#
st2 <- asr.marginal(lik2, pars)
names(pars) = names(coef(fit2))#
pars["mu0"] = 0#
pars["mu1"] = 0#
st2 <- asr.marginal(lik2, pars)
set.seed(47) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.05, 0.1, 0.15)#
bisse_params = pars#
birthRate = pars[1]#
deathRate = pars[3]#
#
set.seed(48) # Rare to have a transition, but observed here#
phy <- trees(pars, "bisse", max.taxa=4, max.t=Inf, x0=0)[[1]]#
write.tree(phy, file="")#
#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik <- make.bisse(phy, phy$tip.state)#
phy$tip.state#
#
bisse_2areas = lik#
#fit <- find.mle(lik, pars, method="subplex")#
# MLE doesn't make much sense with tiny data#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
coef(fit)#
st <- asr.marginal(lik, coef(fit))#
nodelabels(thermo=t(st), piecol=cols, cex=0.5)#
t(st)#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
# Res1t is BiSSE default#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
#
# Compare to Julia:#
# > LnLs1#
# [1] -9.574440 -6.670978#
# > LnLs1t#
# [1] -7.464283 -6.670978#
EsDs = t(attr(res1t,"intermediates")$init)#
sum(log(rowSums(EsDs[,3:4])))#
attr(res1t,"intermediates")$lq#
sum(attr(res1t,"intermediates")$lq)#
#
# This corresponds to:#
# Julia_sum_lq_nodes = sum(log.(sum.(res.likes_at_each_nodeIndex_branchTop))) + Julia_sum_lq#
# R_sum_lq_nodes = R_result_sum_log_computed_likelihoods_at_each_node_x_lambda#
sum(log(rowSums(EsDs[,3:4]))) + sum(attr(res1t,"intermediates")$lq)#
# ...but is double-counting lnLs#
########################################################
# Look at ASRs#
########################################################
########################################################
# TRYING TO FIT TO SIMULATED DATA#
# This **FAILS** with such tiny data#
########################################################
########################################################
# Look at find.mle#
########################################################
methods("find.mle")#
diversitree:::find.mle.default#
diversitree:::find.mle.dtlik#
diversitree:::find.mle.mixed#
diversitree:::do.mle.search#
# change to create some ambiguity#
#
phy2 = phy#
#
plot(phy2, label.offset=0.1)#
tiplabels(text=phy2$tip.state, tip=1:4, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik2 <- make.bisse(phy2, phy2$tip.state)#
fit2 <- find.mle(func=lik2, x.init=coef(fit), method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
coef(fit2 )#
#fit2 <- find.mle(lik2, pars, method="subplex", fail.value=-1e10)#
st2 <- asr.marginal(lik2, coef(fit2))#
names(pars) = names(coef(fit2))#
pars["mu0"] = 0#
pars["mu1"] = 0#
st2 <- asr.marginal(lik2, pars)
st2
tr
phy
plot(phy)
axisPhylo()
lik
res1t
?asr.marginal
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
t(st2)
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
st2 <- asr.marginal(lik2, pars)
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
t(st2)#
st2 <- asr.marginal(lik2, pars)#
t(st2)
attr(res1t,"intermediates")$root.p
attr(res1,"intermediates")$root.p#
attr(res2,"intermediates")$root.p#
attr(res3,"intermediates")$root.p#
attr(res4,"intermediates")$root.p#
attr(res5,"intermediates")$root.p#
attr(res6,"intermediates")$root.p#
#
attr(res1t,"intermediates")$root.p#
attr(res2t,"intermediates")$root.p#
attr(res3t,"intermediates")$root.p#
attr(res4t,"intermediates")$root.p#
attr(res5t,"intermediates")$root.p#
attr(res6t,"intermediates")$root.p
rbind(attr(res6t,"intermediates")$root.p#
,attr(res6t,"intermediates")$root.p#
,attr(res6t,"intermediates")$root.p#
)
tmpmat = rbind(attr(res1,"intermediates")$root.p, #
attr(res2,"intermediates")$root.p, #
attr(res3,"intermediates")$root.p, #
attr(res4,"intermediates")$root.p, #
attr(res5,"intermediates")$root.p, #
attr(res6,"intermediates")$root.p, #
attr(res1t,"intermediates")$root.p, #
attr(res2t,"intermediates")$root.p, #
attr(res3t,"intermediates")$root.p, #
attr(res4t,"intermediates")$root.p, #
attr(res5t,"intermediates")$root.p, #
attr(res6t,"intermediates")$root.p#
)
tmpmat
tmpmat = rbind(attr(res1,"intermediates")$root.p, #
attr(res2,"intermediates")$root.p, #
attr(res3,"intermediates")$root.p, #
attr(res4,"intermediates")$root.p, #
attr(res5,"intermediates")$root.p, #
attr(res6,"intermediates")$root.p, #
attr(res1t,"intermediates")$root.p, #
attr(res2t,"intermediates")$root.p, #
attr(res3t,"intermediates")$root.p, #
attr(res4t,"intermediates")$root.p, #
attr(res5t,"intermediates")$root.p, #
attr(res6t,"intermediates")$root.p#
)#
#
tmpnames = paste0("ancstate", seq(1,ncol(tmpmat),1))
tmpnames
tmpmat = rbind(attr(res1,"intermediates")$root.p, #
attr(res2,"intermediates")$root.p, #
attr(res3,"intermediates")$root.p, #
attr(res4,"intermediates")$root.p, #
attr(res5,"intermediates")$root.p, #
attr(res6,"intermediates")$root.p, #
attr(res1t,"intermediates")$root.p, #
attr(res2t,"intermediates")$root.p, #
attr(res3t,"intermediates")$root.p, #
attr(res4t,"intermediates")$root.p, #
attr(res5t,"intermediates")$root.p, #
attr(res6t,"intermediates")$root.p#
)#
#
tmpnames = paste0("ancstate", seq(1,ncol(tmpmat),1))#
#
tmprownames = c("res1", "res2", "res3", "res4", "res5", "res6", "res1t", "res2t", "res3t", "res4t", "res5t", "res6t")#
#
rootstates_df = adf2(tmpmat)#
names(rootstates_df) = tmpnames#
row.names(rootstates_df) = tmprownames#
rootstates_df
phy2 = phy#
#
plot(phy2, label.offset=0.1)#
tiplabels(text=phy2$tip.state, tip=1:4, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik2 <- make.bisse(phy2, phy2$tip.state)#
fit2 <- find.mle(func=lik2, x.init=coef(fit), method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
coef(fit2 )#
#fit2 <- find.mle(lik2, pars, method="subplex", fail.value=-1e10)#
st2 <- asr.marginal(lik2, coef(fit2))#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)#
#
names(pars) = names(coef(fit2))#
st2 <- asr.marginal(lik2, pars)#
t(st2)
pars
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.05, 0.1, 0.15)#
orig_pars = pars
# change to create some ambiguity#
#
phy2 = phy#
#
plot(phy2, label.offset=0.1)#
tiplabels(text=phy2$tip.state, tip=1:4, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik2 <- make.bisse(phy2, phy2$tip.state)#
fit2 <- find.mle(func=lik2, x.init=coef(fit), method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
coef(fit2 )#
#fit2 <- find.mle(lik2, pars, method="subplex", fail.value=-1e10)#
st2 <- asr.marginal(lik2, coef(fit2))#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)#
#
orig_pars = pars#
names(pars) = names(coef(fit2))#
st2 <- asr.marginal(lik2, pars)#
t(st2)
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)
t(st2)
ROOT.OBS
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, condition.surv=TRUE)#
t(st2)
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, condition.surv=FALSE)
t(st2)
st2 <- asr.marginal(lik2, pars, condition.surv=TRUE)#
t(st2)
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, condition.surv=TRUE)#
t(st2)
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, condition.surv=FALSE)#
t(st2)
res1
t(attr(res1,"intermediates")$init)
rootnode = length(phy$tip.label)+1#
EsDs = t(attr(res1,"intermediates")$init)#
EsDs[rootnode, 3:4]#
EsDs[rootnode, 3:4] / sum(EsDs[rootnode, 3:4])
rootnode = length(phy$tip.label)+1#
EsDs = t(attr(res2,"intermediates")$init)#
EsDs[rootnode, 3:4]#
EsDs[rootnode, 3:4] / sum(EsDs[rootnode, 3:4])
rootnode = length(phy$tip.label)+1#
EsDs = t(attr(res3,"intermediates")$init)#
EsDs[rootnode, 3:4] / sum(EsDs[rootnode, 3:4])
rootnode = length(phy$tip.label)+1#
EsDs = t(attr(res4,"intermediates")$init)#
EsDs[rootnode, 3:4] / sum(EsDs[rootnode, 3:4])
rootnode = length(phy$tip.label)+1#
EsDs = t(attr(res5,"intermediates")$init)#
EsDs[rootnode, 3:4] / sum(EsDs[rootnode, 3:4])
rootnode = length(phy$tip.label)+1#
EsDs = t(attr(res6,"intermediates")$init)#
EsDs[rootnode, 3:4] / sum(EsDs[rootnode, 3:4])
rootnode = length(phy$tip.label)+1#
EsDs = t(attr(res6t,"intermediates")$init)#
EsDs[rootnode, 3:4] / sum(EsDs[rootnode, 3:4])
res1
t(st2)
solver_options.solver = CVODE_BDF{:Newton, :GMRES, Nothing, Nothing}(0, 0, 0, false, 10, 5, 7, 3, 10, nothing, nothing, 0)#
#solver_options.solver = Tsit5()#
solver_options.solver = Vern9()#
solver_options.abstol = 1e-6#
solver_options.reltol = 1e-6#
solver_options.save_everystep = false#
include("/GitHub/PhyBEARS.jl/notes/nodeOp_Cmat_uppass_v12.jl")#
tspan = (anctime, dectime)#
#
prob_Ds_v5 = DifferentialEquations.ODEProblem(calcDs_4states2A, u0, tspan, p_Ds_v5);#
sol_Ds_v5 = solve(prob_Ds_v5, solver_options.solver, save_everystep=solver_options.save_everystep, abstol=solver_options.abstol, reltol=solver_options.reltol);#
#
sol_Ds_v5(anctime)#
sol_Ds_v5(anctime) ./ sum(sol_Ds_v5(anctime))#
sol_Ds_v5(dectime)#
lbranch_top = sol_Ds_v5(dectime) ./ sum(sol_Ds_v5(dectime))#
#
uppass_likes = lbranch_top .* res.normlikes_at_each_nodeIndex_branchTop[lnode]#
uppass_likes ./ sum(uppass_likes)
library(BioGeoBEARS)#
library(diversitree)#
source("/GitHub/PhyBEARS.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/PhyBEARS.jl/Rsrc/ClaSSE_functions_v3.R")#
#
## Start with a simple tree evolved under a BiSSE with all rates#
## asymmetric:#
# lambda0, lambda1, mu0, mu1, q01, q10#
#
# Gives weird result -- green nodes, blue truth#
set.seed(47) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.05, 0.1, 0.15)#
orig_pars = pars#
bisse_params = pars#
birthRate = pars[1]#
deathRate = pars[3]#
#
set.seed(48) # Rare to have a transition, but observed here#
phy <- trees(pars, "bisse", max.taxa=4, max.t=Inf, x0=0)[[1]]#
write.tree(phy, file="")#
#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik <- make.bisse(phy, phy$tip.state)#
phy$tip.state#
#
bisse_2areas = lik#
#fit <- find.mle(lik, pars, method="subplex")#
# MLE doesn't make much sense with tiny data#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
coef(fit)#
st <- asr.marginal(lik, coef(fit))#
nodelabels(thermo=t(st), piecol=cols, cex=0.5)#
t(st)#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
# Res1t is BiSSE default#
# "lik" matches res1t#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
#
# Compare to Julia:#
# > LnLs1#
# [1] -9.574440 -6.670978#
# > LnLs1t#
# [1] -7.464283 -6.670978#
EsDs = t(attr(res1t,"intermediates")$init)#
sum(log(rowSums(EsDs[,3:4])))#
attr(res1t,"intermediates")$lq#
sum(attr(res1t,"intermediates")$lq)#
#
# This corresponds to:#
# Julia_sum_lq_nodes = sum(log.(sum.(res.likes_at_each_nodeIndex_branchTop))) + Julia_sum_lq#
# R_sum_lq_nodes = R_result_sum_log_computed_likelihoods_at_each_node_x_lambda#
sum(log(rowSums(EsDs[,3:4]))) + sum(attr(res1t,"intermediates")$lq)#
# ...but is double-counting lnLs#
########################################################
# Look at ASRs#
########################################################
tmpmat = rbind(attr(res1,"intermediates")$root.p, #
attr(res2,"intermediates")$root.p, #
attr(res3,"intermediates")$root.p, #
attr(res4,"intermediates")$root.p, #
attr(res5,"intermediates")$root.p, #
attr(res6,"intermediates")$root.p, #
attr(res1t,"intermediates")$root.p, #
attr(res2t,"intermediates")$root.p, #
attr(res3t,"intermediates")$root.p, #
attr(res4t,"intermediates")$root.p, #
attr(res5t,"intermediates")$root.p, #
attr(res6t,"intermediates")$root.p#
)#
#
tmpnames = paste0("ancstate", seq(1,ncol(tmpmat),1))#
#
tmprownames = c("res1", "res2", "res3", "res4", "res5", "res6", "res1t", "res2t", "res3t", "res4t", "res5t", "res6t")#
#
rootstates_df = adf2(tmpmat)#
names(rootstates_df) = tmpnames#
row.names(rootstates_df) = tmprownames#
rootstates_df#
#
# rootstates_df#
#       ancstate1 ancstate2#
# res1  0.4303571 0.5696429 # <- this is what asr.marginal gives#
# res2  0.5000000 0.5000000#
# res3  0.0000000 1.0000000#
# res4  0.2500000 0.7500000#
# res5  0.5000000 0.5000000#
# res6  0.5392658 0.4607342#
# res1t 0.4303571 0.5696429 # <- this is what asr.marginal gives#
# res2t 0.5000000 0.5000000#
# res3t 0.0000000 1.0000000#
# res4t 0.2500000 0.7500000#
# res5t 0.5000000 0.5000000#
# res6t 0.5392658 0.4607342#
#
# Same for everything:#
rootnode = length(phy$tip.label)+1#
EsDs = t(attr(res1,"intermediates")$init)#
EsDs[rootnode, 3:4] / sum(EsDs[rootnode, 3:4])#
########################################################
# TRYING TO FIT TO SIMULATED DATA#
# This **FAILS** with such tiny data#
########################################################
########################################################
# Look at find.mle#
########################################################
methods("find.mle")#
diversitree:::find.mle.default#
diversitree:::find.mle.dtlik#
diversitree:::find.mle.mixed#
diversitree:::do.mle.search#
# change to create some ambiguity#
#
phy2 = phy#
#
plot(phy2, label.offset=0.1)#
tiplabels(text=phy2$tip.state, tip=1:4, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik2 <- make.bisse(phy2, phy2$tip.state)#
fit2 <- find.mle(func=lik2, x.init=coef(fit), method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
coef(fit2 )#
#fit2 <- find.mle(lik2, pars, method="subplex", fail.value=-1e10)#
st2 <- asr.marginal(lik2, coef(fit2))#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)#
#
orig_pars = pars#
names(pars) = names(coef(fit2))#
st2 <- asr.marginal(lik2, pars)#
t(st2)#
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, condition.surv=FALSE)#
t(st2)#
#
# t(st2)#
#             [,1]         [,2]#
# [1,] 0.430357148 0.5696428522  # <- matches res1 or res1t#
# [2,] 0.005145312 0.9948546878#
# [3,] 0.999681941 0.0003180585#
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, condition.surv=TRUE)#
t(st2)#
# > t(st2)#
#           [,1]        [,2]#
# [1,] 0.49926227 0.500737731#
# [2,] 0.00570688 0.994293120#
# [3,] 0.99963639 0.000363611#
# Turn off extinction; the speciation/extinction thing dominates on large branches I guess#
pars["mu0"] = 0#
pars["mu1"] = 0#
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
t(st2)#
st2 <- asr.marginal(lik2, pars)#
t(st2)#
#
########################################################
# Edit to clarify node structure#
########################################################
st2[,1] = c(0.5, 0.5)#
st2[,2] = c(0.75, 0.25)#
st2[,3] = c(1.0, 0.0)#
#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
# So, this shows nodes 5,6,7:#
t(st2)
include("/GitHub/PhyBEARS.jl/notes/nodeOp_Cmat_uppass_v12.jl")#
#
ctable1 = prtCp(p_Ds_v5)#
make_ctable_single_events(ctable1)#
u0 = left_likes#
prob_Ds_v5 = DifferentialEquations.ODEProblem(calcDs_4states2G, u0, tspan, p_Ds_v5);#
sol_Ds_v5 = solve(prob_Ds_v5, solver_options.solver, save_everystep=solver_options.save_everystep, abstol=solver_options.abstol, reltol=solver_options.reltol);#
#
sol_Ds_v5(anctime)#
sol_Ds_v5(anctime) ./ sum(sol_Ds_v5(anctime))#
sol_Ds_v5(dectime)#
rbranch_top = sol_Ds_v5(dectime) ./ sum(sol_Ds_v5(dectime))#
#
uppass_likes = rbranch_top .* res.normlikes_at_each_nodeIndex_branchTop[rnode]#
asr_at_node7 = uppass_likes ./ sum(uppass_likes)#
#
# calcDs_4states2B, calcDs_4states2C   # <- closest! (and same)#
#  0.9996842305583383#
#  0.00031576944166156017#
# Diversitree: asr.marginal#
# 0.999620338 0.0003796623#
#
diversitree_bisse_Rnode7_01 = [0.999620338, 0.0003796623]#
asr_at_node7 .== diversitree_bisse_Rnode7_01#
#
@test round(asr_at_node7[1]; digits=3) .== round(diversitree_bisse_Rnode7_01[1]; digits=3)#
@test round(asr_at_node7[2]; digits=3) .== round(diversitree_bisse_Rnode7_01[2]; digits=3)
methods("find.mle")#
diversitree:::find.mle.default#
diversitree:::find.mle.dtlik#
diversitree:::find.mle.mixed#
diversitree:::do.mle.search#
# change to create some ambiguity#
#
phy2 = phy#
#
plot(phy2, label.offset=0.1)#
tiplabels(text=phy2$tip.state, tip=1:4, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik2 <- make.bisse(phy2, phy2$tip.state)#
fit2 <- find.mle(func=lik2, x.init=coef(fit), method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
coef(fit2 )#
#fit2 <- find.mle(lik2, pars, method="subplex", fail.value=-1e10)#
st2 <- asr.marginal(lik2, coef(fit2))#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)#
#
orig_pars = pars#
names(pars) = names(coef(fit2))#
st2 <- asr.marginal(lik2, pars)#
t(st2)#
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, condition.surv=FALSE)#
t(st2)
library(BioGeoBEARS)#
library(diversitree)#
source("/GitHub/PhyBEARS.jl/Rsrc/ClaSSE_mods_v2.R")#
source("/GitHub/PhyBEARS.jl/Rsrc/ClaSSE_functions_v3.R")#
#
## Start with a simple tree evolved under a BiSSE with all rates#
## asymmetric:#
# lambda0, lambda1, mu0, mu1, q01, q10#
#
# Gives weird result -- green nodes, blue truth#
set.seed(47) # Rare to have a transition, but observed here#
pars <- c(0.222222222, 0.222222222, 0.111111111, 0.05, 0.1, 0.15)#
orig_pars = pars#
bisse_params = pars#
birthRate = pars[1]#
deathRate = pars[3]#
#
set.seed(48) # Rare to have a transition, but observed here#
phy <- trees(pars, "bisse", max.taxa=4, max.t=Inf, x0=0)[[1]]#
write.tree(phy, file="")#
#
cols = c("blue", "green3")#
lower = rep(0.0, times=length(pars))#
upper = rep(10.0, times=length(pars))#
#
## Here is the true history#
h <- history.from.sim.discrete(phy, 0:1)#
diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik <- make.bisse(phy, phy$tip.state)#
phy$tip.state#
#
bisse_2areas = lik#
#fit <- find.mle(lik, pars, method="subplex")#
# MLE doesn't make much sense with tiny data#
fit <- find.mle(func=lik, x.init=pars, method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
coef(fit)#
st <- asr.marginal(lik, coef(fit))#
nodelabels(thermo=t(st), piecol=cols, cex=0.5)#
t(st)#
res1 = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
res2 = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0, 1)#
res3 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.25, 0.75)#
res4 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
root_probs = c(0.5,0.5)#
res5 = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=FALSE)#
res6 = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=FALSE)#
#
# Res1t is BiSSE default#
# "lik" matches res1t#
res1t = bisse_2areas(pars=bisse_params, root=ROOT.OBS, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
res2t = bisse_2areas(pars=bisse_params, root=ROOT.FLAT, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0, 1)#
res3t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.25, 0.75)#
res4t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
root_probs = c(0.5,0.5)#
res5t = bisse_2areas(pars=bisse_params, root=ROOT.GIVEN, root.p=root_probs, intermediates=TRUE, condition.surv=TRUE)#
res6t = bisse_2areas(pars=bisse_params, root=ROOT.EQUI, root.p=NULL, intermediates=TRUE, condition.surv=TRUE)#
# get_classe_LnLs returns the total log-likelihood, and #
# the total of the branch likelihoods#
LnLs1 = get_classe_LnLs(res1)#
LnLs2 = get_classe_LnLs(res2)#
LnLs3 = get_classe_LnLs(res3)#
LnLs4 = get_classe_LnLs(res4)#
LnLs5 = get_classe_LnLs(res5)#
LnLs6 = get_classe_LnLs(res6)#
LnLs1t = get_classe_LnLs(res1t)#
LnLs2t = get_classe_LnLs(res2t)#
LnLs3t = get_classe_LnLs(res3t)#
LnLs4t = get_classe_LnLs(res4t)#
LnLs5t = get_classe_LnLs(res5t)#
LnLs6t = get_classe_LnLs(res6t)#
#
LnLst = as.data.frame(rbind(LnLs1, LnLs2, LnLs3, LnLs4, LnLs5, LnLs6, LnLs1t, LnLs2t, LnLs3t, LnLs4t, LnLs5t, LnLs6t), stringsAsFactors=FALSE)#
names(LnLst) = c("ttl_LnL", "branch_LnL")#
ObsDiff = (LnLst$ttl_LnL - LnLst$branch_LnL)#
exp_ObsDiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL))#
LnLdiff = round((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)), digits=4)#
exp_LnLdiff = exp((LnLst$ttl_LnL - LnLst$branch_LnL - log(birthRate)))#
LnLst2 = cbind(LnLst, ObsDiff, LnLdiff, exp_ObsDiff, exp_LnLdiff)#
cft(LnLst2, numdigits_inbetween_have_fixed_digits=8)#
#
# Compare to Julia:#
# > LnLs1#
# [1] -9.574440 -6.670978#
# > LnLs1t#
# [1] -7.464283 -6.670978#
EsDs = t(attr(res1t,"intermediates")$init)#
sum(log(rowSums(EsDs[,3:4])))#
attr(res1t,"intermediates")$lq#
sum(attr(res1t,"intermediates")$lq)#
#
# This corresponds to:#
# Julia_sum_lq_nodes = sum(log.(sum.(res.likes_at_each_nodeIndex_branchTop))) + Julia_sum_lq#
# R_sum_lq_nodes = R_result_sum_log_computed_likelihoods_at_each_node_x_lambda#
sum(log(rowSums(EsDs[,3:4]))) + sum(attr(res1t,"intermediates")$lq)#
# ...but is double-counting lnLs#
########################################################
# Look at ASRs#
########################################################
tmpmat = rbind(attr(res1,"intermediates")$root.p, #
attr(res2,"intermediates")$root.p, #
attr(res3,"intermediates")$root.p, #
attr(res4,"intermediates")$root.p, #
attr(res5,"intermediates")$root.p, #
attr(res6,"intermediates")$root.p, #
attr(res1t,"intermediates")$root.p, #
attr(res2t,"intermediates")$root.p, #
attr(res3t,"intermediates")$root.p, #
attr(res4t,"intermediates")$root.p, #
attr(res5t,"intermediates")$root.p, #
attr(res6t,"intermediates")$root.p#
)#
#
tmpnames = paste0("ancstate", seq(1,ncol(tmpmat),1))#
#
tmprownames = c("res1", "res2", "res3", "res4", "res5", "res6", "res1t", "res2t", "res3t", "res4t", "res5t", "res6t")#
#
rootstates_df = adf2(tmpmat)#
names(rootstates_df) = tmpnames#
row.names(rootstates_df) = tmprownames#
rootstates_df#
#
# rootstates_df#
#       ancstate1 ancstate2#
# res1  0.4303571 0.5696429 # <- this is what asr.marginal gives#
# res2  0.5000000 0.5000000#
# res3  0.0000000 1.0000000#
# res4  0.2500000 0.7500000#
# res5  0.5000000 0.5000000#
# res6  0.5392658 0.4607342#
# res1t 0.4303571 0.5696429 # <- this is what asr.marginal gives#
# res2t 0.5000000 0.5000000#
# res3t 0.0000000 1.0000000#
# res4t 0.2500000 0.7500000#
# res5t 0.5000000 0.5000000#
# res6t 0.5392658 0.4607342#
#
# Same for everything:#
rootnode = length(phy$tip.label)+1#
EsDs = t(attr(res1,"intermediates")$init)#
EsDs[rootnode, 3:4] / sum(EsDs[rootnode, 3:4])#
########################################################
# TRYING TO FIT TO SIMULATED DATA#
# This **FAILS** with such tiny data#
########################################################
########################################################
# Look at find.mle#
########################################################
methods("find.mle")#
diversitree:::find.mle.default#
diversitree:::find.mle.dtlik#
diversitree:::find.mle.mixed#
diversitree:::do.mle.search#
# change to create some ambiguity#
#
phy2 = phy#
#
plot(phy2, label.offset=0.1)#
tiplabels(text=phy2$tip.state, tip=1:4, col="black", bg=cols[phy2$tip.state+1])#
#diversitree:::plot.history(h, phy, main="True history", cols=cols)#
#
lik2 <- make.bisse(phy2, phy2$tip.state)#
fit2 <- find.mle(func=lik2, x.init=coef(fit), method="subplex", fail.value=-1e10, lower=lower, upper=upper)#
coef(fit2 )#
#fit2 <- find.mle(lik2, pars, method="subplex", fail.value=-1e10)#
st2 <- asr.marginal(lik2, coef(fit2))#
nodelabels(thermo=t(st2), piecol=cols, cex=0.5)#
t(st2)#
#
orig_pars = pars#
names(pars) = names(coef(fit2))#
st2 <- asr.marginal(lik2, pars)#
t(st2)#
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, condition.surv=FALSE)#
t(st2)
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, condition.surv=TRUE)#
t(st2)
orig_pars = pars#
names(pars) = names(coef(fit2))#
st2 <- asr.marginal(lik2, pars)#
t(st2)
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, root.p=NULL, condition.surv=FALSE)#
t(st2)
st2 <- asr.marginal(lik2, pars, root=ROOT.OBS, condition.surv=TRUE)#
t(st2)
library(ape)
rotate
? rotate
library(ape)#
library(BioGeoBEARS)#
#
# Try some basic commands: Tree reading with APE#
newick_string = "(orang:12.0,((chimp:6.0,(human:2.5,Lucy:0.5):3.5):1.0,gorilla:7.0):5.0);"#
tr = read.tree(file="", text=newick_string)#
tr#
plot(tr)#
title("Example phylogeny: great apes")#
axisPhylo() # plots timescale#
mtext(text="Mega-annum (Ma)", side=1, line=2)#
# Try some basic commands: BioGeoBEARS#
#
# The function "prt": prints the tree to a table#
# This can be very handy for understanding R node numbers,#
# the APE phylo object tree structure, etc.#
trtable = prt(tr, printflag=FALSE, get_tipnames=TRUE, fossils_older_than=0.001)#
trtable#
# Ladderize the tree#
tr2 = ladderize(tr, right=FALSE)#
plot(tr2)#
title("Example phylogeny: great apes, ladderized")#
axisPhylo() # plots timescale#
mtext(text="Mega-annum (Ma)", side=1, line=2)#
#
trtable2 = prt(tr2, printflag=FALSE, get_tipnames=TRUE, fossils_older_than=0.001)#
trtable2#
#
# Rotate a node#
tr3 = rotate(phy=tr2, node=9)
plot_BioGeoBEARS_results
library(BioGeoBEARS)
get_indices_where_list1_occurs_in_list2
library(devtools)#
devtools::install_github(repo="nmatzke/BioGeoBEARS", INSTALL_opts="--byte-compile")
library(BioGeoBEARS)
remove.packages("lifecycle")
install.packages("lifecycle")
library(lifecycle)
detach(lifecycle)
detach("lifecycle")
library(lifecycle)
library(BioGeoBEARS)
library(optimx)   # optimx seems better than R's default optim()#
library(GenSA)    # GenSA seems better than optimx (but slower) on 5+ parameters, #
                  # seems to sometimes fail on simple problems (2-3 parameters)#
library(FD)       # for FD::maxent() (make sure this is up-to-date)#
library(snow)     # (if you want to use multicore functionality; some systems/R versions prefer library(parallel), try either)#
library(parallel)#
#
########################################################
# 2018-10-10 update: I have been putting the #
# updates on CRAN/GitHub#
# You should use:#
# rexpokit version 0.26.6 from CRAN#
# cladoRcpp version 0.15 from CRAN#
# BioGeoBEARS version 1.1 from GitHub, install with:#
# library(devtools)#
# devtools::install_github(repo="nmatzke/BioGeoBEARS")#
########################################################
library(rexpokit)#
library(cladoRcpp)#
library(BioGeoBEARS)#
#
########################################################
# CUT: The old instructions to source() online upgrade .R files have been deleted,#
#         all updates are now on the GitHub version of the package, version 1.1+#
########################################################
#
########################################################
# (This local-sourcing is mostly useful for Nick, while actively developing)#
# Local source()-ing method -- uses BioGeoBEARS sourceall() function #
# on a directory of .R files, so you don't have to type them out.#
# The directories here are on my machine, you would have to make a #
# directory, save the .R files there, and refer to them.#
##
# NOTE: it's best to source the "cladoRcpp.R" update first, to avoid warnings like this:#
###
## Note: possible error in 'rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs = tmpca_1, ': #
##         unused arguments (m = m, m_null_range = include_null_range, jts_matrix = jts_matrix) #
###
##
# TO USE: Delete or comment out the 'source("http://...")' commands above, and un-comment#
#              the below...#
#########################################################################
# Un-comment (and fix directory paths) to use:#
#library(BioGeoBEARS)#
#source("/drives/Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp.R")#
#sourceall("/drives/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#calc_loglike_sp = compiler::cmpfun(calc_loglike_sp_prebyte)    # crucial to fix bug in uppass calculations#
#calc_independent_likelihoods_on_each_branch = compiler::cmpfun(calc_independent_likelihoods_on_each_branch_prebyte)#
#########################################################################
#
########################################################
# SETUP: YOUR WORKING DIRECTORY#
########################################################
# You will need to set your working directory to match your local system#
#
# Note these very handy functions!#
# Command "setwd(x)" sets your working directory#
# Command "getwd()" gets your working directory and tells you what it is.#
# Command "list.files()" lists the files in your working directory#
# To get help on any command, use "?".  E.g., "?list.files"#
#
# Set your working directory for output files#
# default here is your home directory ("~")#
# Change this as you like#
wd = np("~")#
setwd(wd)#
#
# Double-check your working directory with getwd()#
getwd()#
#
########################################################
# SETUP: Extension data directory#
########################################################
# When R packages contain extra files, they are stored in the "extdata" directory #
# inside the installed package.#
##
# BioGeoBEARS contains various example files and scripts in its extdata directory.#
# #
# Each computer operating system might install BioGeoBEARS in a different place, #
# depending on your OS and settings. #
# #
# However, you can find the extdata directory like this:#
extdata_dir = np(system.file("extdata", package="BioGeoBEARS"))#
extdata_dir#
list.files(extdata_dir)#
#
# "system.file" looks in the directory of a specified package (in this case BioGeoBEARS)#
# The function "np" is just a shortcut for normalizePath(), which converts the #
# path to the format appropriate for your system (e.g., Mac/Linux use "/", but #
# Windows uses "\\", if memory serves).#
#
# Even when using your own data files, you should KEEP these commands in your #
# script, since the plot_BioGeoBEARS_results function needs a script from the #
# extdata directory to calculate the positions of "corners" on the plot. This cannot#
# be made into a straight up BioGeoBEARS function because it uses C routines #
# from the package APE which do not pass R CMD check for some reason.#
#
########################################################
# SETUP: YOUR TREE FILE AND GEOGRAPHY FILE#
########################################################
# Example files are given below. To run your own data,#
# make the below lines point to your own files, e.g.#
# trfn = "/mydata/frogs/frogBGB/tree.newick"#
# geogfn = "/mydata/frogs/frogBGB/geog.data"#
#
########################################################
# Phylogeny file#
# Notes: #
# 1. Must be binary/bifurcating: no polytomies#
# 2. No negative branchlengths (e.g. BEAST MCC consensus trees sometimes have negative branchlengths)#
# 3. Be careful of very short branches, as BioGeoBEARS will interpret ultrashort branches as direct ancestors#
# 4. You can use non-ultrametric trees, but BioGeoBEARS will interpret any tips significantly below the #
#    top of the tree as fossils!  This is only a good idea if you actually do have fossils in your tree,#
#    as in e.g. Wood, Matzke et al. (2013), Systematic Biology.#
# 5. The default settings of BioGeoBEARS make sense for trees where the branchlengths are in units of #
#    millions of years, and the tree is 1-1000 units tall. If you have a tree with a total height of#
#    e.g. 0.00001, you will need to adjust e.g. the max values of d and e, or (simpler) multiply all#
#    your branchlengths to get them into reasonable units.#
# 6. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
########################################################
# This is the example Newick file for Hawaiian Psychotria#
# (from Ree & Smith 2008)#
# "trfn" = "tree file name"#
trfn = np(paste(addslash(extdata_dir), "Psychotria_5.2.newick", sep=""))#
#
# Look at the raw Newick file:#
moref(trfn)#
#
# Look at your phylogeny (plots to a PDF, which avoids issues with multiple graphics in same window):#
pdffn = "tree.pdf"#
pdf(file=pdffn, width=9, height=12)#
#
tr = read.tree(trfn)#
tr#
plot(tr)#
title("Example Psychotria phylogeny from Ree & Smith (2008)")#
axisPhylo() # plots timescale#
#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)#
#
########################################################
# Geography file#
# Notes:#
# 1. This is a PHYLIP-formatted file. This means that in the #
#    first line, #
#    - the 1st number equals the number of rows (species)#
#    - the 2nd number equals the number of columns (number of areas)#
#    - after a tab, put the areas in parentheses, with spaces: (A B C D)#
##
# 1.5. Example first line:#
#    10    4    (A B C D)#
# #
# 2. The second line, and subsequent lines:#
#    speciesA    0110#
#    speciesB    0111#
#    speciesC    0001#
#         ...#
# #
# 2.5a. This means a TAB between the species name and the area 0/1s#
# 2.5b. This also means NO SPACE AND NO TAB between the area 0/1s.#
# #
# 3. See example files at:#
#    http://phylo.wikidot.com/biogeobears#files#
# #
# 4. Make you understand what a PLAIN-TEXT EDITOR is:#
#    http://phylo.wikidot.com/biogeobears#texteditors#
##
# 3. The PHYLIP format is the same format used for C++ LAGRANGE geography files.#
##
# 4. All names in the geography file must match names in the phylogeny file.#
##
# 5. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
##
# 6. Operational taxonomic units (OTUs) should ideally be phylogenetic lineages, #
#    i.e. genetically isolated populations.  These may or may not be identical #
#    with species.  You would NOT want to just use specimens, as each specimen #
#    automatically can only live in 1 area, which will typically favor DEC+J #
#    models.  This is fine if the species/lineages really do live in single areas,#
#    but you wouldn't want to assume this without thinking about it at least. #
#    In summary, you should collapse multiple specimens into species/lineages if #
#    data indicates they are the same genetic population.#
#######################################################
#
# This is the example geography file for Hawaiian Psychotria#
# (from Ree & Smith 2008)#
geogfn = np(paste(addslash(extdata_dir), "Psychotria_geog.data", sep=""))#
#
# Look at the raw geography text file:#
moref(geogfn)#
#
# Look at your geographic range data:#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Maximum range size observed:#
max(rowSums(dfnums_to_numeric(tipranges@df)))#
#
# Set the maximum number of areas any species may occupy; this cannot be larger #
# than the number of areas you set up, but it can be smaller.#
max_range_size = 4#
#
#####################################################
#####################################################
# KEY HINT: The number of states (= number of different possible geographic ranges)#
# depends on (a) the number of areas and (b) max_range_size.#
# If you have more than about 500-600 states, the calculations will get REALLY slow,#
# since the program has to exponentiate a matrix of e.g. 600x600.  Often the computer#
# will just sit there and crunch, and never get through the calculation of the first#
# likelihood.#
# #
# (this is also what is usually happening when LAGRANGE hangs: you have too many states!)#
##
# To check the number of states for a given number of ranges, try:#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=FALSE)#
numstates_from_numareas(numareas=4, maxareas=3, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=2, include_null_range=TRUE)#
#
# Large numbers of areas have problems:#
numstates_from_numareas(numareas=10, maxareas=10, include_null_range=TRUE)#
#
# ...unless you limit the max_range_size:#
numstates_from_numareas(numareas=10, maxareas=2, include_null_range=TRUE)#
#####################################################
#####################################################
#
########################################################
########################################################
# DEC AND DEC+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DEC" model is identical with #
# the Lagrange DEC model, and should return identical#
# ML estimates of parameters, and the same #
# log-likelihoods, for the same datasets.#
##
# Ancestral state probabilities at nodes will be slightly #
# different, since BioGeoBEARS is reporting the #
# ancestral state probabilities under the global ML#
# model, and Lagrange is reporting ancestral state#
# probabilities after re-optimizing the likelihood#
# after fixing the state at each node. These will #
# be similar, but not identical. See Matzke (2014),#
# Systematic Biology, for discussion.#
##
# Also see Matzke (2014) for presentation of the #
# DEC+J model.#
########################################################
########################################################
#
########################################################
########################################################
#
########################################################
# Run DEC#
########################################################
#
# Intitialize a default model (DEC model)#
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
#
# Give BioGeoBEARS the location of the phylogeny Newick file#
BioGeoBEARS_run_object$trfn = trfn#
#
# Give BioGeoBEARS the location of the geography text file#
BioGeoBEARS_run_object$geogfn = geogfn#
#
# Input the maximum range size#
BioGeoBEARS_run_object$max_range_size = max_range_size#
#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; OMeara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
# 1. Here, un-comment ONLY the files you want to use.#
# 2. Also un-comment "BioGeoBEARS_run_object = section_the_tree(...", below.#
# 3. For example files see (a) extdata_dir, #
#  or (b) http://phylo.wikidot.com/biogeobears#files#
#  and BioGeoBEARS Google Group posts for further hints)#
##
# Uncomment files you wish to use in time-stratified analyses:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx();#
# if "GenSA", use Generalized Simulated Annealing, which seems better on high-dimensional#
# problems (5+ parameters), but seems to sometimes fail to optimize on simple problems#
BioGeoBEARS_run_object$num_cores_to_use = 1#
# (use more cores to speed it up; this requires#
# library(parallel) and/or library(snow). The package "parallel" #
# is now default on Macs in R 3.0+, but apparently still #
# has to be typed on some Windows machines. Note: apparently #
# parallel works on Mac command-line R, but not R.app.#
# BioGeoBEARS checks for this and resets to 1#
# core with R.app)#
#
# Sparse matrix exponentiation is an option for huge numbers of ranges/states (600+)#
# I have experimented with sparse matrix exponentiation in EXPOKIT/rexpokit,#
# but the results are imprecise and so I haven't explored it further.#
# In a Bayesian analysis, it might work OK, but the ML point estimates are#
# not identical.#
# Also, I have not implemented all functions to work with force_sparse=TRUE.#
# Volunteers are welcome to work on it!!#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC model#
# (nothing to do; defaults)#
#
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.#
BioGeoBEARS_run_object#
#
# This contains the model object#
BioGeoBEARS_run_object$BioGeoBEARS_model_object#
#
# This table contains the parameters of the model #
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table#
#
# Run this to check inputs. Read the error messages if you get them!#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# For a slow analysis, run once, then set runslow=FALSE to just #
# load the saved result.#
runslow = TRUE#
resfn = "Psychotria_DEC_M0_unconstrained_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDEC = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDEC = res#
    }#
#
########################################################
# Run DEC+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; OMeara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx();#
# if "GenSA", use Generalized Simulated Annealing, which seems better on high-dimensional#
# problems (5+ parameters), but seems to sometimes fail to optimize on simple problems#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDEC$outputs@params_table["d","est"]#
estart = resDEC$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Add j as a free parameter#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "Psychotria_DEC+J_M0_unconstrained_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDECj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDECj = res#
    }#
#
########################################################
# PDF plots#
########################################################
pdffn = "Psychotria_DEC_vs_DEC+J_M0_unconstrained_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - DEC#
########################################################
analysis_titletxt ="BioGeoBEARS DEC on Psychotria M0_unconstrained"#
#
# Setup#
results_object = resDEC#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - DECJ#
########################################################
analysis_titletxt ="BioGeoBEARS DEC+J on Psychotria M0_unconstrained"#
#
# Setup#
results_object = resDECj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()  # Turn off PDF#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr) # Plot it
warnings()
library(devtools)#
devtools::install_github(repo="nmatzke/BioGeoBEARS", INSTALL_opts="--byte-compile")
library(devtools)#
devtools::install_github(repo="nmatzke/BioGeoBEARS", INSTALL_opts="--byte-compile")
#
  building BioGeoBEARS_1.1.2.tar.gzs/apes_SSE/apes_DEC+J_M0_unconstrained_v#
   Warning in utils::tar(filepath, pkgname, compression = compression, compression_level = 9L,  :#
     storing paths of more than 100 bytes is not portable:#
     BioGeoBEARS/inst/extdata/examples/395lab/Psychotria_M4_DistanceDispersal/Psychotria_M4_DistanceDispersal_v1.R#
   Warning in utils::tar(filepath, pkgname, compression = compression, compression_level = 9L,  :#
     storing paths of more than 100 bytes is not portable:#
     BioGeoBEARS/inst/extdata/examples/BSM_3taxa/M3areas_allowed/3taxa_DIVALIKE_vs_DIVALIKE+J_M3areas_allowed_v1.pdf#
   Warning in utils::tar(filepath, pkgname, compression = compression, compression_level = 9L,  :#
     storing paths of more than 100 bytes is not portable:#
     BioGeoBEARS/inst/extdata/examples/Psychotria_M3strat/BSM_to_simmap/Psychotria_DEC_vs_DEC+J_M3areas_allowed_v1.pdf#
   Warning in utils::tar(filepath, pkgname, compression = compression, compression_level = 9L,  :#
     storing paths of more than 100 bytes is not portable:#
     BioGeoBEARS/inst/extdata/examples/Psychotria_M3strat/BSM_to_simmap/Psychotria_DIVALIKE+J_M3areas_allowed_v1.Rdata#
   Warning in utils::tar(filepath, pkgname, compression = compression, compression_level = 9L,  :#
     storing paths of more than 100 bytes is not portable:#
     BioGeoBEARS/inst/extdata/examples/Psychotria_M3strat/BSM_to_simmap/Psychotria_DIVALIKE_M3areas_allowed_v1.Rdata#
   Warning in utils::tar(filepath, pkgname, compression = compression, compression_level = 9L,  :#
     storing paths of more than 100 bytes is not portable:#
     BioGeoBEARS/inst/extdata/examples/Psychotria_M3strat/BSM_to_simmap/Psychotria_DIVALIKE_vs_DIVALIKE+J_M3areas_allowed_v1.pdf#
   Warning in utils::tar(filepath, pkgname, compression = compression, compression_level = 9L,  :#
     storing paths of more than 100 bytes is not portable:#
     BioGeoBEARS/inst/extdata/examples/Psychotria_M3strat/BSM_to_simmap/RES_ana_events_tables_PARTIAL.Rdata#
   Warning in utils::tar(filepath, pkgname, compression = compression, compression_level = 9L,  :#
     storing paths of more than 100 bytes is not portable:#
     BioGeoBEARS/inst/extdata/examples/Psychotria_M3strat/BSM_to_simmap/all_dispersals_counts_fromto_means.txt#
   Warning in utils::tar(filepath, pkgname, compression = compression, compression_level = 9L,  :#
     storing paths of more than 100 bytes is not portable:#
     BioGeoBEARS/inst/extdata/examples/Psychotria_M3strat/BSM_to_simmap/all_dispersals_counts_fromto_sds.txt#
   Warning in utils::tar(filepath, pkgname, compression = compression, compression_level = 9L,  :#
   storing paths of more than 100 bytes is n Warning in utils::tar(filepath, pkgname, compression = compression, compression_level = 9L,  :#
#
Sys.getenv("R_MAX_NUM_DLLS"):	[1] "1000"#
Loading ~/.Rprofile...#
Currently viewed PATH:#
/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/local/ncbi/blast/bin:/usr/texbin:/usr/local/ncbi/blast/bin:/usr/texbin#
* installing *source* package BioGeoBEARS ...#
** using staged installation#
** R#
** inst#
** byte-compile and prepare package for lazy loading
library(optimx)   # optimx seems better than R's default optim()#
library(GenSA)    # GenSA seems better than optimx (but slower) on 5+ parameters, #
                  # seems to sometimes fail on simple problems (2-3 parameters)#
library(FD)       # for FD::maxent() (make sure this is up-to-date)#
library(snow)     # (if you want to use multicore functionality; some systems/R versions prefer library(parallel), try either)#
library(parallel)#
#
########################################################
# 2018-10-10 update: I have been putting the #
# updates on CRAN/GitHub#
# You should use:#
# rexpokit version 0.26.6 from CRAN#
# cladoRcpp version 0.15 from CRAN#
# BioGeoBEARS version 1.1 from GitHub, install with:#
# library(devtools)#
# devtools::install_github(repo="nmatzke/BioGeoBEARS")#
########################################################
library(rexpokit)#
library(cladoRcpp)#
library(BioGeoBEARS)#
#
########################################################
# CUT: The old instructions to source() online upgrade .R files have been deleted,#
#         all updates are now on the GitHub version of the package, version 1.1+#
########################################################
#
########################################################
# (This local-sourcing is mostly useful for Nick, while actively developing)#
# Local source()-ing method -- uses BioGeoBEARS sourceall() function #
# on a directory of .R files, so you don't have to type them out.#
# The directories here are on my machine, you would have to make a #
# directory, save the .R files there, and refer to them.#
##
# NOTE: it's best to source the "cladoRcpp.R" update first, to avoid warnings like this:#
###
## Note: possible error in 'rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs = tmpca_1, ': #
##         unused arguments (m = m, m_null_range = include_null_range, jts_matrix = jts_matrix) #
###
##
# TO USE: Delete or comment out the 'source("http://...")' commands above, and un-comment#
#              the below...#
#########################################################################
# Un-comment (and fix directory paths) to use:#
#library(BioGeoBEARS)#
#source("/drives/Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp.R")#
#sourceall("/drives/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#calc_loglike_sp = compiler::cmpfun(calc_loglike_sp_prebyte)    # crucial to fix bug in uppass calculations#
#calc_independent_likelihoods_on_each_branch = compiler::cmpfun(calc_independent_likelihoods_on_each_branch_prebyte)#
#########################################################################
#
########################################################
# SETUP: YOUR WORKING DIRECTORY#
########################################################
# You will need to set your working directory to match your local system#
#
# Note these very handy functions!#
# Command "setwd(x)" sets your working directory#
# Command "getwd()" gets your working directory and tells you what it is.#
# Command "list.files()" lists the files in your working directory#
# To get help on any command, use "?".  E.g., "?list.files"#
#
# Set your working directory for output files#
# default here is your home directory ("~")#
# Change this as you like#
wd = np("~")#
setwd(wd)#
#
# Double-check your working directory with getwd()#
getwd()#
#
########################################################
# SETUP: Extension data directory#
########################################################
# When R packages contain extra files, they are stored in the "extdata" directory #
# inside the installed package.#
##
# BioGeoBEARS contains various example files and scripts in its extdata directory.#
# #
# Each computer operating system might install BioGeoBEARS in a different place, #
# depending on your OS and settings. #
# #
# However, you can find the extdata directory like this:#
extdata_dir = np(system.file("extdata", package="BioGeoBEARS"))#
extdata_dir#
list.files(extdata_dir)#
#
# "system.file" looks in the directory of a specified package (in this case BioGeoBEARS)#
# The function "np" is just a shortcut for normalizePath(), which converts the #
# path to the format appropriate for your system (e.g., Mac/Linux use "/", but #
# Windows uses "\\", if memory serves).#
#
# Even when using your own data files, you should KEEP these commands in your #
# script, since the plot_BioGeoBEARS_results function needs a script from the #
# extdata directory to calculate the positions of "corners" on the plot. This cannot#
# be made into a straight up BioGeoBEARS function because it uses C routines #
# from the package APE which do not pass R CMD check for some reason.#
#
########################################################
# SETUP: YOUR TREE FILE AND GEOGRAPHY FILE#
########################################################
# Example files are given below. To run your own data,#
# make the below lines point to your own files, e.g.#
# trfn = "/mydata/frogs/frogBGB/tree.newick"#
# geogfn = "/mydata/frogs/frogBGB/geog.data"#
#
########################################################
# Phylogeny file#
# Notes: #
# 1. Must be binary/bifurcating: no polytomies#
# 2. No negative branchlengths (e.g. BEAST MCC consensus trees sometimes have negative branchlengths)#
# 3. Be careful of very short branches, as BioGeoBEARS will interpret ultrashort branches as direct ancestors#
# 4. You can use non-ultrametric trees, but BioGeoBEARS will interpret any tips significantly below the #
#    top of the tree as fossils!  This is only a good idea if you actually do have fossils in your tree,#
#    as in e.g. Wood, Matzke et al. (2013), Systematic Biology.#
# 5. The default settings of BioGeoBEARS make sense for trees where the branchlengths are in units of #
#    millions of years, and the tree is 1-1000 units tall. If you have a tree with a total height of#
#    e.g. 0.00001, you will need to adjust e.g. the max values of d and e, or (simpler) multiply all#
#    your branchlengths to get them into reasonable units.#
# 6. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
########################################################
# This is the example Newick file for Hawaiian Psychotria#
# (from Ree & Smith 2008)#
# "trfn" = "tree file name"#
trfn = np(paste(addslash(extdata_dir), "Psychotria_5.2.newick", sep=""))#
#
# Look at the raw Newick file:#
moref(trfn)#
#
# Look at your phylogeny (plots to a PDF, which avoids issues with multiple graphics in same window):#
pdffn = "tree.pdf"#
pdf(file=pdffn, width=9, height=12)#
#
tr = read.tree(trfn)#
tr#
plot(tr)#
title("Example Psychotria phylogeny from Ree & Smith (2008)")#
axisPhylo() # plots timescale#
#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)#
#
########################################################
# Geography file#
# Notes:#
# 1. This is a PHYLIP-formatted file. This means that in the #
#    first line, #
#    - the 1st number equals the number of rows (species)#
#    - the 2nd number equals the number of columns (number of areas)#
#    - after a tab, put the areas in parentheses, with spaces: (A B C D)#
##
# 1.5. Example first line:#
#    10    4    (A B C D)#
# #
# 2. The second line, and subsequent lines:#
#    speciesA    0110#
#    speciesB    0111#
#    speciesC    0001#
#         ...#
# #
# 2.5a. This means a TAB between the species name and the area 0/1s#
# 2.5b. This also means NO SPACE AND NO TAB between the area 0/1s.#
# #
# 3. See example files at:#
#    http://phylo.wikidot.com/biogeobears#files#
# #
# 4. Make you understand what a PLAIN-TEXT EDITOR is:#
#    http://phylo.wikidot.com/biogeobears#texteditors#
##
# 3. The PHYLIP format is the same format used for C++ LAGRANGE geography files.#
##
# 4. All names in the geography file must match names in the phylogeny file.#
##
# 5. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
##
# 6. Operational taxonomic units (OTUs) should ideally be phylogenetic lineages, #
#    i.e. genetically isolated populations.  These may or may not be identical #
#    with species.  You would NOT want to just use specimens, as each specimen #
#    automatically can only live in 1 area, which will typically favor DEC+J #
#    models.  This is fine if the species/lineages really do live in single areas,#
#    but you wouldn't want to assume this without thinking about it at least. #
#    In summary, you should collapse multiple specimens into species/lineages if #
#    data indicates they are the same genetic population.#
#######################################################
#
# This is the example geography file for Hawaiian Psychotria#
# (from Ree & Smith 2008)#
geogfn = np(paste(addslash(extdata_dir), "Psychotria_geog.data", sep=""))#
#
# Look at the raw geography text file:#
moref(geogfn)#
#
# Look at your geographic range data:#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Maximum range size observed:#
max(rowSums(dfnums_to_numeric(tipranges@df)))#
#
# Set the maximum number of areas any species may occupy; this cannot be larger #
# than the number of areas you set up, but it can be smaller.#
max_range_size = 4#
#
#####################################################
#####################################################
# KEY HINT: The number of states (= number of different possible geographic ranges)#
# depends on (a) the number of areas and (b) max_range_size.#
# If you have more than about 500-600 states, the calculations will get REALLY slow,#
# since the program has to exponentiate a matrix of e.g. 600x600.  Often the computer#
# will just sit there and crunch, and never get through the calculation of the first#
# likelihood.#
# #
# (this is also what is usually happening when LAGRANGE hangs: you have too many states!)#
##
# To check the number of states for a given number of ranges, try:#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=FALSE)#
numstates_from_numareas(numareas=4, maxareas=3, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=2, include_null_range=TRUE)#
#
# Large numbers of areas have problems:#
numstates_from_numareas(numareas=10, maxareas=10, include_null_range=TRUE)#
#
# ...unless you limit the max_range_size:#
numstates_from_numareas(numareas=10, maxareas=2, include_null_range=TRUE)#
#####################################################
#####################################################
#
########################################################
########################################################
# DEC AND DEC+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DEC" model is identical with #
# the Lagrange DEC model, and should return identical#
# ML estimates of parameters, and the same #
# log-likelihoods, for the same datasets.#
##
# Ancestral state probabilities at nodes will be slightly #
# different, since BioGeoBEARS is reporting the #
# ancestral state probabilities under the global ML#
# model, and Lagrange is reporting ancestral state#
# probabilities after re-optimizing the likelihood#
# after fixing the state at each node. These will #
# be similar, but not identical. See Matzke (2014),#
# Systematic Biology, for discussion.#
##
# Also see Matzke (2014) for presentation of the #
# DEC+J model.#
########################################################
########################################################
#
########################################################
########################################################
#
########################################################
# Run DEC#
########################################################
#
# Intitialize a default model (DEC model)#
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
#
# Give BioGeoBEARS the location of the phylogeny Newick file#
BioGeoBEARS_run_object$trfn = trfn#
#
# Give BioGeoBEARS the location of the geography text file#
BioGeoBEARS_run_object$geogfn = geogfn#
#
# Input the maximum range size#
BioGeoBEARS_run_object$max_range_size = max_range_size#
#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; OMeara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
# 1. Here, un-comment ONLY the files you want to use.#
# 2. Also un-comment "BioGeoBEARS_run_object = section_the_tree(...", below.#
# 3. For example files see (a) extdata_dir, #
#  or (b) http://phylo.wikidot.com/biogeobears#files#
#  and BioGeoBEARS Google Group posts for further hints)#
##
# Uncomment files you wish to use in time-stratified analyses:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx();#
# if "GenSA", use Generalized Simulated Annealing, which seems better on high-dimensional#
# problems (5+ parameters), but seems to sometimes fail to optimize on simple problems#
BioGeoBEARS_run_object$num_cores_to_use = 1#
# (use more cores to speed it up; this requires#
# library(parallel) and/or library(snow). The package "parallel" #
# is now default on Macs in R 3.0+, but apparently still #
# has to be typed on some Windows machines. Note: apparently #
# parallel works on Mac command-line R, but not R.app.#
# BioGeoBEARS checks for this and resets to 1#
# core with R.app)#
#
# Sparse matrix exponentiation is an option for huge numbers of ranges/states (600+)#
# I have experimented with sparse matrix exponentiation in EXPOKIT/rexpokit,#
# but the results are imprecise and so I haven't explored it further.#
# In a Bayesian analysis, it might work OK, but the ML point estimates are#
# not identical.#
# Also, I have not implemented all functions to work with force_sparse=TRUE.#
# Volunteers are welcome to work on it!!#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC model#
# (nothing to do; defaults)#
#
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.#
BioGeoBEARS_run_object#
#
# This contains the model object#
BioGeoBEARS_run_object$BioGeoBEARS_model_object#
#
# This table contains the parameters of the model #
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table#
#
# Run this to check inputs. Read the error messages if you get them!#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# For a slow analysis, run once, then set runslow=FALSE to just #
# load the saved result.#
runslow = TRUE#
resfn = "Psychotria_DEC_M0_unconstrained_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDEC = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDEC = res#
    }#
#
########################################################
# Run DEC+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; OMeara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx();#
# if "GenSA", use Generalized Simulated Annealing, which seems better on high-dimensional#
# problems (5+ parameters), but seems to sometimes fail to optimize on simple problems#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDEC$outputs@params_table["d","est"]#
estart = resDEC$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Add j as a free parameter#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "Psychotria_DEC+J_M0_unconstrained_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDECj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDECj = res#
    }#
#
########################################################
# PDF plots#
########################################################
pdffn = "Psychotria_DEC_vs_DEC+J_M0_unconstrained_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - DEC#
########################################################
analysis_titletxt ="BioGeoBEARS DEC on Psychotria M0_unconstrained"#
#
# Setup#
results_object = resDEC#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - DECJ#
########################################################
analysis_titletxt ="BioGeoBEARS DEC+J on Psychotria M0_unconstrained"#
#
# Setup#
results_object = resDECj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()  # Turn off PDF#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr) # Plot it
resDECj
# Load the package (after installation, see above).#
library(optimx)   # optimx seems better than R's default optim()#
library(GenSA)    # GenSA seems better than optimx (but slower) on 5+ parameters, #
                  # seems to sometimes fail on simple problems (2-3 parameters)#
library(FD)       # for FD::maxent() (make sure this is up-to-date)#
library(snow)     # (if you want to use multicore functionality; some systems/R versions prefer library(parallel), try either)#
library(parallel)#
#
########################################################
# 2018-10-10 update: I have been putting the #
# updates on CRAN/GitHub#
# You should use:#
# rexpokit version 0.26.6 from CRAN#
# cladoRcpp version 0.15 from CRAN#
# BioGeoBEARS version 1.1 from GitHub, install with:#
# library(devtools)#
# devtools::install_github(repo="nmatzke/BioGeoBEARS")#
########################################################
library(rexpokit)#
library(cladoRcpp)#
library(BioGeoBEARS)#
#
########################################################
# CUT: The old instructions to source() online upgrade .R files have been deleted,#
#         all updates are now on the GitHub version of the package, version 1.1+#
########################################################
#
########################################################
# (This local-sourcing is mostly useful for Nick, while actively developing)#
# Local source()-ing method -- uses BioGeoBEARS sourceall() function #
# on a directory of .R files, so you don't have to type them out.#
# The directories here are on my machine, you would have to make a #
# directory, save the .R files there, and refer to them.#
##
# NOTE: it's best to source the "cladoRcpp.R" update first, to avoid warnings like this:#
###
## Note: possible error in 'rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs = tmpca_1, ': #
##         unused arguments (m = m, m_null_range = include_null_range, jts_matrix = jts_matrix) #
###
##
# TO USE: Delete or comment out the 'source("http://...")' commands above, and un-comment#
#              the below...#
#########################################################################
# Un-comment (and fix directory paths) to use:#
#library(BioGeoBEARS)#
#source("/drives/Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp.R")#
#sourceall("/drives/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#calc_loglike_sp = compiler::cmpfun(calc_loglike_sp_prebyte)    # crucial to fix bug in uppass calculations#
#calc_independent_likelihoods_on_each_branch = compiler::cmpfun(calc_independent_likelihoods_on_each_branch_prebyte)#
#########################################################################
#
########################################################
# SETUP: YOUR WORKING DIRECTORY#
########################################################
# You will need to set your working directory to match your local system#
#
# Note these very handy functions!#
# Command "setwd(x)" sets your working directory#
# Command "getwd()" gets your working directory and tells you what it is.#
# Command "list.files()" lists the files in your working directory#
# To get help on any command, use "?".  E.g., "?list.files"#
#
# Set your working directory for output files#
# default here is your home directory ("~")#
# Change this as you like#
wd = "/GitHub/PhyBEARS.jl/test/apes_SSE/"#
setwd(wd)#
#
# Double-check your working directory with getwd()#
getwd()#
#
########################################################
# SETUP: Extension data directory#
########################################################
# When R packages contain extra files, they are stored in the "extdata" directory #
# inside the installed package.#
##
# BioGeoBEARS contains various example files and scripts in its extdata directory.#
# #
# Each computer operating system might install BioGeoBEARS in a different place, #
# depending on your OS and settings. #
# #
# However, you can find the extdata directory like this:#
extdata_dir = np(system.file("extdata", package="BioGeoBEARS"))#
extdata_dir#
list.files(extdata_dir)#
#
# "system.file" looks in the directory of a specified package (in this case BioGeoBEARS)#
# The function "np" is just a shortcut for normalizePath(), which converts the #
# path to the format appropriate for your system (e.g., Mac/Linux use "/", but #
# Windows uses "\\", if memory serves).#
#
# Even when using your own data files, you should KEEP these commands in your #
# script, since the plot_BioGeoBEARS_results function needs a script from the #
# extdata directory to calculate the positions of "corners" on the plot. This cannot#
# be made into a straight up BioGeoBEARS function because it uses C routines #
# from the package APE which do not pass R CMD check for some reason.#
#
########################################################
# SETUP: YOUR TREE FILE AND GEOGRAPHY FILE#
########################################################
# Example files are given below. To run your own data,#
# make the below lines point to your own files, e.g.#
# trfn = "/mydata/frogs/frogBGB/tree.newick"#
# geogfn = "/mydata/frogs/frogBGB/geog.data"#
#
########################################################
# Phylogeny file#
# Notes: #
# 1. Must be binary/bifurcating: no polytomies#
# 2. No negative branchlengths (e.g. BEAST MCC consensus trees sometimes have negative branchlengths)#
# 3. Be careful of very short branches, as BioGeoBEARS will interpret ultrashort branches as direct ancestors#
# 4. You can use non-ultrametric trees, but BioGeoBEARS will interpret any tips significantly below the #
#    top of the tree as fossils!  This is only a good idea if you actually do have fossils in your tree,#
#    as in e.g. Wood, Matzke et al. (2013), Systematic Biology.#
# 5. The default settings of BioGeoBEARS make sense for trees where the branchlengths are in units of #
#    millions of years, and the tree is 1-1000 units tall. If you have a tree with a total height of#
#    e.g. 0.00001, you will need to adjust e.g. the max values of d and e, or (simpler) multiply all#
#    your branchlengths to get them into reasonable units.#
# 6. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
########################################################
# This is the example Newick file for Hawaiian apes#
# (from Ree & Smith 2008)#
# "trfn" = "tree file name"#
trfn = "apes_tree.newick"#
#
# Look at the raw Newick file:#
moref(trfn)#
#
# Look at your phylogeny (plots to a PDF, which avoids issues with multiple graphics in same window):#
pdffn = "tree.pdf"#
pdf(file=pdffn, width=9, height=12)#
#
tr = read.tree(trfn)#
tr#
plot(tr)#
title("Example apes phylogeny")#
axisPhylo() # plots timescale#
#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)#
#
########################################################
# Geography file#
# Notes:#
# 1. This is a PHYLIP-formatted file. This means that in the #
#    first line, #
#    - the 1st number equals the number of rows (species)#
#    - the 2nd number equals the number of columns (number of areas)#
#    - after a tab, put the areas in parentheses, with spaces: (A B C D)#
##
# 1.5. Example first line:#
#    10    4    (A B C D)#
# #
# 2. The second line, and subsequent lines:#
#    speciesA    0110#
#    speciesB    0111#
#    speciesC    0001#
#         ...#
# #
# 2.5a. This means a TAB between the species name and the area 0/1s#
# 2.5b. This also means NO SPACE AND NO TAB between the area 0/1s.#
# #
# 3. See example files at:#
#    http://phylo.wikidot.com/biogeobears#files#
# #
# 4. Make you understand what a PLAIN-TEXT EDITOR is:#
#    http://phylo.wikidot.com/biogeobears#texteditors#
##
# 3. The PHYLIP format is the same format used for C++ LAGRANGE geography files.#
##
# 4. All names in the geography file must match names in the phylogeny file.#
##
# 5. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
##
# 6. Operational taxonomic units (OTUs) should ideally be phylogenetic lineages, #
#    i.e. genetically isolated populations.  These may or may not be identical #
#    with species.  You would NOT want to just use specimens, as each specimen #
#    automatically can only live in 1 area, which will typically favor DEC+J #
#    models.  This is fine if the species/lineages really do live in single areas,#
#    but you wouldn't want to assume this without thinking about it at least. #
#    In summary, you should collapse multiple specimens into species/lineages if #
#    data indicates they are the same genetic population.#
#######################################################
#
# This is the example geography file for Hawaiian apes#
# (from Ree & Smith 2008)#
geogfn = "geog.data"#
#
# Look at the raw geography text file:#
moref(geogfn)#
#
# Look at your geographic range data:#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Maximum range size observed:#
max(rowSums(dfnums_to_numeric(tipranges@df)))#
#
# Set the maximum number of areas any species may occupy; this cannot be larger #
# than the number of areas you set up, but it can be smaller.#
max_range_size = 2#
#
#####################################################
#####################################################
# KEY HINT: The number of states (= number of different possible geographic ranges)#
# depends on (a) the number of areas and (b) max_range_size.#
# If you have more than about 500-600 states, the calculations will get REALLY slow,#
# since the program has to exponentiate a matrix of e.g. 600x600.  Often the computer#
# will just sit there and crunch, and never get through the calculation of the first#
# likelihood.#
# #
# (this is also what is usually happening when LAGRANGE hangs: you have too many states!)#
##
# To check the number of states for a given number of ranges, try:#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=FALSE)#
numstates_from_numareas(numareas=4, maxareas=3, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=2, include_null_range=TRUE)#
#
# Large numbers of areas have problems:#
numstates_from_numareas(numareas=10, maxareas=10, include_null_range=TRUE)#
#
# ...unless you limit the max_range_size:#
numstates_from_numareas(numareas=10, maxareas=2, include_null_range=TRUE)#
#####################################################
#####################################################
#
########################################################
########################################################
# DEC AND DEC+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DEC" model is identical with #
# the Lagrange DEC model, and should return identical#
# ML estimates of parameters, and the same #
# log-likelihoods, for the same datasets.#
##
# Ancestral state probabilities at nodes will be slightly #
# different, since BioGeoBEARS is reporting the #
# ancestral state probabilities under the global ML#
# model, and Lagrange is reporting ancestral state#
# probabilities after re-optimizing the likelihood#
# after fixing the state at each node. These will #
# be similar, but not identical. See Matzke (2014),#
# Systematic Biology, for discussion.#
##
# Also see Matzke (2014) for presentation of the #
# DEC+J model.#
########################################################
########################################################
#
########################################################
########################################################
#
########################################################
# Run DEC#
########################################################
#
# Intitialize a default model (DEC model)#
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
#
# Give BioGeoBEARS the location of the phylogeny Newick file#
BioGeoBEARS_run_object$trfn = trfn#
#
# Give BioGeoBEARS the location of the geography text file#
BioGeoBEARS_run_object$geogfn = geogfn#
#
# Input the maximum range size#
BioGeoBEARS_run_object$max_range_size = max_range_size#
#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; OMeara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
# 1. Here, un-comment ONLY the files you want to use.#
# 2. Also un-comment "BioGeoBEARS_run_object = section_the_tree(...", below.#
# 3. For example files see (a) extdata_dir, #
#  or (b) http://phylo.wikidot.com/biogeobears#files#
#  and BioGeoBEARS Google Group posts for further hints)#
##
# Uncomment files you wish to use in time-stratified analyses:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx();#
# if "GenSA", use Generalized Simulated Annealing, which seems better on high-dimensional#
# problems (5+ parameters), but seems to sometimes fail to optimize on simple problems#
BioGeoBEARS_run_object$num_cores_to_use = 1#
# (use more cores to speed it up; this requires#
# library(parallel) and/or library(snow). The package "parallel" #
# is now default on Macs in R 3.0+, but apparently still #
# has to be typed on some Windows machines. Note: apparently #
# parallel works on Mac command-line R, but not R.app.#
# BioGeoBEARS checks for this and resets to 1#
# core with R.app)#
#
# Sparse matrix exponentiation is an option for huge numbers of ranges/states (600+)#
# I have experimented with sparse matrix exponentiation in EXPOKIT/rexpokit,#
# but the results are imprecise and so I haven't explored it further.#
# In a Bayesian analysis, it might work OK, but the ML point estimates are#
# not identical.#
# Also, I have not implemented all functions to work with force_sparse=TRUE.#
# Volunteers are welcome to work on it!!#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC model#
# (nothing to do; defaults)#
#
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.#
BioGeoBEARS_run_object#
#
# This contains the model object#
BioGeoBEARS_run_object$BioGeoBEARS_model_object#
#
# This table contains the parameters of the model #
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table#
#
# Run this to check inputs. Read the error messages if you get them!#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# For a slow analysis, run once, then set runslow=FALSE to just #
# load the saved result.#
runslow = TRUE#
resfn = "apes_DEC_M0_unconstrained_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDEC = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDEC = res#
    }#
########################################################
# For comparison to PhyBEARS#
########################################################
res = resDEC#
names(res)#
#
resDEC$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS#
resDEC$ML_marginal_prob_each_state_at_branch_top_AT_node#
resDEC$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS#
#
mats = get_Qmat_COOmat_from_res(resDEC)#
Qmat = mats$Qmat#
#
u0 = resDEC$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[6,]#
result = u0 %*% expm(Qmat)#
#
result == resDEC$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS[6,]#
#
resDEC$ML_marginal_prob_each_state_at_branch_top_AT_node#
#
cft(resDEC$ML_marginal_prob_each_state_at_branch_bottom_below_node, digits=4)#
cft(resDEC$ML_marginal_prob_each_state_at_branch_top_AT_node, digits=4)#
#
paste0(c(resDEC$ML_marginal_prob_each_state_at_branch_bottom_below_node), collapse=", ")#
paste0(c(resDEC$ML_marginal_prob_each_state_at_branch_top_AT_node), collapse=", ")#
########################################################
# Run DEC+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; OMeara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx();#
# if "GenSA", use Generalized Simulated Annealing, which seems better on high-dimensional#
# problems (5+ parameters), but seems to sometimes fail to optimize on simple problems#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDEC$outputs@params_table["d","est"]#
estart = resDEC$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Add j as a free parameter#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "apes_DEC+J_M0_unconstrained_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDECj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDECj = res#
    }#
########################################################
# For comparison to PhyBEARS#
########################################################
res = resDECj#
names(res)#
#
resDECj$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS#
resDECj$ML_marginal_prob_each_state_at_branch_top_AT_node#
resDECj$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS#
#
mats = get_Qmat_COOmat_from_res(resDECj)#
Qmat = mats$Qmat#
#
u0 = resDECj$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[6,]#
result = u0 %*% expm(Qmat)#
#
result == resDECj$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS[6,]#
#
resDECj$ML_marginal_prob_each_state_at_branch_top_AT_node#
#
cft(resDECj$ML_marginal_prob_each_state_at_branch_bottom_below_node, digits=4)#
cft(resDECj$ML_marginal_prob_each_state_at_branch_top_AT_node, digits=4)
c(resDECj$ML_marginal_prob_each_state_at_branch_bottom_below_node)
cat(c(resDECj$ML_marginal_prob_each_state_at_branch_bottom_below_node), sep=", ")
cat(c(resDECj$ML_marginal_prob_each_state_at_branch_bottom_below_node), sep=", ")#
#
cat(c(resDECj$ML_marginal_prob_each_state_at_branch_top_AT_node), sep=", ")
resDECj$total_loglikelihood
resDECj$output
########################################################
########################################################
# DIVALIKE AND DIVALIKE+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DIVALIKE" model is not identical with #
# Ronquist (1997)'s parsimony DIVA. It is a likelihood#
# interpretation of DIVA, constructed by modelling DIVA's#
# processes the way DEC does, but only allowing the #
# processes DIVA allows (widespread vicariance: yes; subset#
# sympatry: no; see Ronquist & Sanmartin 2011, Figure 4).#
##
# DIVALIKE is a likelihood interpretation of parsimony#
# DIVA, and it is "like DIVA" -- similar to, but not#
# identical to, parsimony DIVA.#
##
# I thus now call the model "DIVALIKE", and you should also. ;-)#
########################################################
########################################################
#
########################################################
# Run DIVALIKE#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; OMeara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx();#
# if "GenSA", use Generalized Simulated Annealing, which seems better on high-dimensional#
# problems (5+ parameters), but seems to sometimes fail to optimize on simple problems#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DIVALIKE model#
# Remove subset-sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "2-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "ysv*1/2"#
#
# Allow classic, widespread vicariance; all events equiprobable#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","init"] = 0.5#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","est"] = 0.5#
#
# No jump dispersal/founder-event speciation#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = 0.01#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = 0.01#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
runslow = TRUE#
resfn = "apes_DIVALIKE_M0_unconstrained_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDIVALIKE = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDIVALIKE = res#
    }#
#
########################################################
# Run DIVALIKE+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; OMeara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx();#
# if "GenSA", use Generalized Simulated Annealing, which seems better on high-dimensional#
# problems (5+ parameters), but seems to sometimes fail to optimize on simple problems#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DIVALIKE+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDIVALIKE$outputs@params_table["d","est"]#
estart = resDIVALIKE$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Remove subset-sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "2-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "ysv*1/2"#
#
# Allow classic, widespread vicariance; all events equiprobable#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","init"] = 0.5#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","est"] = 0.5#
#
# Add jump dispersal/founder-event speciation#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
# Under DIVALIKE+J, the max of "j" should be 2, not 3 (as is default in DEC+J)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","min"] = 0.00001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 1.99999#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "apes_DIVALIKE+J_M0_unconstrained_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDIVALIKEj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDIVALIKEj = res#
    }#
#
pdffn = "apes_DIVALIKE_vs_DIVALIKE+J_M0_unconstrained_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - DIVALIKE#
########################################################
analysis_titletxt ="BioGeoBEARS DIVALIKE on apes M0_unconstrained"#
#
# Setup#
results_object = resDIVALIKE#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - DIVALIKE+J#
########################################################
analysis_titletxt ="BioGeoBEARS DIVALIKE+J on apes M0_unconstrained"#
#
# Setup#
results_object = resDIVALIKEj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)#
res = resDIVALIKE#
names(res)#
#
resDIVALIKE$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS#
resDIVALIKE$ML_marginal_prob_each_state_at_branch_top_AT_node#
resDIVALIKE$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS#
#
mats = get_Qmat_COOmat_from_res(resDIVALIKE)#
Qmat = mats$Qmat#
#
u0 = resDIVALIKE$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[6,]#
result = u0 %*% expm(Qmat)#
#
result == resDIVALIKE$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS[6,]#
#
resDIVALIKE$ML_marginal_prob_each_state_at_branch_top_AT_node#
#
cft(resDIVALIKE$ML_marginal_prob_each_state_at_branch_bottom_below_node, digits=4)#
cft(resDIVALIKE$ML_marginal_prob_each_state_at_branch_top_AT_node, digits=4)#
cat(c(resDIVALIKE$ML_marginal_prob_each_state_at_branch_bottom_below_node), sep=", ")#
#
cat(c(resDIVALIKE$ML_marginal_prob_each_state_at_branch_top_AT_node), sep=", ")
resDIVALIKE$total_loglikelihood
resDIVALIKE$outputs
res = resDIVALIKE#
names(res)#
#
resDIVALIKE$total_loglikelihood#
resDIVALIKE$outputs["d","est"]#
resDIVALIKE$outputs["e","est"]#
resDIVALIKE$outputs["j","est"]
resDIVALIKE$outputs
resDIVALIKE$outputs@params_table["d","est"]#
resDIVALIKE$outputs@params_table["e","est"]#
resDIVALIKE$outputs@params_table["j","est"]
########################################################
# Run DIVALIKE+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; OMeara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx();#
# if "GenSA", use Generalized Simulated Annealing, which seems better on high-dimensional#
# problems (5+ parameters), but seems to sometimes fail to optimize on simple problems#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DIVALIKE+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDIVALIKE$outputs@params_table["d","est"]#
estart = resDIVALIKE$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Remove subset-sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "2-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "ysv*1/2"#
#
# Allow classic, widespread vicariance; all events equiprobable#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","init"] = 0.5#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","est"] = 0.5#
#
# Add jump dispersal/founder-event speciation#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
# Under DIVALIKE+J, the max of "j" should be 2, not 3 (as is default in DEC+J)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","min"] = 0.00001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 1.99999#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "apes_DIVALIKE+J_M0_unconstrained_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDIVALIKEj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDIVALIKEj = res#
    }
# Load the package (after installation, see above).#
library(optimx)   # optimx seems better than R's default optim()#
library(GenSA)    # GenSA seems better than optimx (but slower) on 5+ parameters, #
                  # seems to sometimes fail on simple problems (2-3 parameters)#
library(FD)       # for FD::maxent() (make sure this is up-to-date)#
library(snow)     # (if you want to use multicore functionality; some systems/R versions prefer library(parallel), try either)#
library(parallel)#
#
########################################################
# 2018-10-10 update: I have been putting the #
# updates on CRAN/GitHub#
# You should use:#
# rexpokit version 0.26.6 from CRAN#
# cladoRcpp version 0.15 from CRAN#
# BioGeoBEARS version 1.1 from GitHub, install with:#
# library(devtools)#
# devtools::install_github(repo="nmatzke/BioGeoBEARS")#
########################################################
library(rexpokit)#
library(cladoRcpp)#
library(BioGeoBEARS)#
#
########################################################
# CUT: The old instructions to source() online upgrade .R files have been deleted,#
#         all updates are now on the GitHub version of the package, version 1.1+#
########################################################
#
########################################################
# (This local-sourcing is mostly useful for Nick, while actively developing)#
# Local source()-ing method -- uses BioGeoBEARS sourceall() function #
# on a directory of .R files, so you don't have to type them out.#
# The directories here are on my machine, you would have to make a #
# directory, save the .R files there, and refer to them.#
##
# NOTE: it's best to source the "cladoRcpp.R" update first, to avoid warnings like this:#
###
## Note: possible error in 'rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs = tmpca_1, ': #
##         unused arguments (m = m, m_null_range = include_null_range, jts_matrix = jts_matrix) #
###
##
# TO USE: Delete or comment out the 'source("http://...")' commands above, and un-comment#
#              the below...#
#########################################################################
# Un-comment (and fix directory paths) to use:#
#library(BioGeoBEARS)#
#source("/drives/Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp.R")#
#sourceall("/drives/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#calc_loglike_sp = compiler::cmpfun(calc_loglike_sp_prebyte)    # crucial to fix bug in uppass calculations#
#calc_independent_likelihoods_on_each_branch = compiler::cmpfun(calc_independent_likelihoods_on_each_branch_prebyte)#
#########################################################################
#
########################################################
# SETUP: YOUR WORKING DIRECTORY#
########################################################
# You will need to set your working directory to match your local system#
#
# Note these very handy functions!#
# Command "setwd(x)" sets your working directory#
# Command "getwd()" gets your working directory and tells you what it is.#
# Command "list.files()" lists the files in your working directory#
# To get help on any command, use "?".  E.g., "?list.files"#
#
# Set your working directory for output files#
# default here is your home directory ("~")#
# Change this as you like#
wd = "/GitHub/PhyBEARS.jl/test/apes_SSE/"#
setwd(wd)#
#
# Double-check your working directory with getwd()#
getwd()#
#
########################################################
# SETUP: Extension data directory#
########################################################
# When R packages contain extra files, they are stored in the "extdata" directory #
# inside the installed package.#
##
# BioGeoBEARS contains various example files and scripts in its extdata directory.#
# #
# Each computer operating system might install BioGeoBEARS in a different place, #
# depending on your OS and settings. #
# #
# However, you can find the extdata directory like this:#
extdata_dir = np(system.file("extdata", package="BioGeoBEARS"))#
extdata_dir#
list.files(extdata_dir)#
#
# "system.file" looks in the directory of a specified package (in this case BioGeoBEARS)#
# The function "np" is just a shortcut for normalizePath(), which converts the #
# path to the format appropriate for your system (e.g., Mac/Linux use "/", but #
# Windows uses "\\", if memory serves).#
#
# Even when using your own data files, you should KEEP these commands in your #
# script, since the plot_BioGeoBEARS_results function needs a script from the #
# extdata directory to calculate the positions of "corners" on the plot. This cannot#
# be made into a straight up BioGeoBEARS function because it uses C routines #
# from the package APE which do not pass R CMD check for some reason.#
#
########################################################
# SETUP: YOUR TREE FILE AND GEOGRAPHY FILE#
########################################################
# Example files are given below. To run your own data,#
# make the below lines point to your own files, e.g.#
# trfn = "/mydata/frogs/frogBGB/tree.newick"#
# geogfn = "/mydata/frogs/frogBGB/geog.data"#
#
########################################################
# Phylogeny file#
# Notes: #
# 1. Must be binary/bifurcating: no polytomies#
# 2. No negative branchlengths (e.g. BEAST MCC consensus trees sometimes have negative branchlengths)#
# 3. Be careful of very short branches, as BioGeoBEARS will interpret ultrashort branches as direct ancestors#
# 4. You can use non-ultrametric trees, but BioGeoBEARS will interpret any tips significantly below the #
#    top of the tree as fossils!  This is only a good idea if you actually do have fossils in your tree,#
#    as in e.g. Wood, Matzke et al. (2013), Systematic Biology.#
# 5. The default settings of BioGeoBEARS make sense for trees where the branchlengths are in units of #
#    millions of years, and the tree is 1-1000 units tall. If you have a tree with a total height of#
#    e.g. 0.00001, you will need to adjust e.g. the max values of d and e, or (simpler) multiply all#
#    your branchlengths to get them into reasonable units.#
# 6. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
########################################################
# This is the example Newick file for Hawaiian apes#
# (from Ree & Smith 2008)#
# "trfn" = "tree file name"#
trfn = "apes_tree.newick"#
#
# Look at the raw Newick file:#
moref(trfn)#
#
# Look at your phylogeny (plots to a PDF, which avoids issues with multiple graphics in same window):#
pdffn = "tree.pdf"#
pdf(file=pdffn, width=9, height=12)#
#
tr = read.tree(trfn)#
tr#
plot(tr)#
title("Example apes phylogeny")#
axisPhylo() # plots timescale#
#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)#
#
########################################################
# Geography file#
# Notes:#
# 1. This is a PHYLIP-formatted file. This means that in the #
#    first line, #
#    - the 1st number equals the number of rows (species)#
#    - the 2nd number equals the number of columns (number of areas)#
#    - after a tab, put the areas in parentheses, with spaces: (A B C D)#
##
# 1.5. Example first line:#
#    10    4    (A B C D)#
# #
# 2. The second line, and subsequent lines:#
#    speciesA    0110#
#    speciesB    0111#
#    speciesC    0001#
#         ...#
# #
# 2.5a. This means a TAB between the species name and the area 0/1s#
# 2.5b. This also means NO SPACE AND NO TAB between the area 0/1s.#
# #
# 3. See example files at:#
#    http://phylo.wikidot.com/biogeobears#files#
# #
# 4. Make you understand what a PLAIN-TEXT EDITOR is:#
#    http://phylo.wikidot.com/biogeobears#texteditors#
##
# 3. The PHYLIP format is the same format used for C++ LAGRANGE geography files.#
##
# 4. All names in the geography file must match names in the phylogeny file.#
##
# 5. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
##
# 6. Operational taxonomic units (OTUs) should ideally be phylogenetic lineages, #
#    i.e. genetically isolated populations.  These may or may not be identical #
#    with species.  You would NOT want to just use specimens, as each specimen #
#    automatically can only live in 1 area, which will typically favor DEC+J #
#    models.  This is fine if the species/lineages really do live in single areas,#
#    but you wouldn't want to assume this without thinking about it at least. #
#    In summary, you should collapse multiple specimens into species/lineages if #
#    data indicates they are the same genetic population.#
#######################################################
#
# This is the example geography file for Hawaiian apes#
# (from Ree & Smith 2008)#
geogfn = "geog.data"#
#
# Look at the raw geography text file:#
moref(geogfn)#
#
# Look at your geographic range data:#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Maximum range size observed:#
max(rowSums(dfnums_to_numeric(tipranges@df)))#
#
# Set the maximum number of areas any species may occupy; this cannot be larger #
# than the number of areas you set up, but it can be smaller.#
max_range_size = 2#
#
#####################################################
#####################################################
# KEY HINT: The number of states (= number of different possible geographic ranges)#
# depends on (a) the number of areas and (b) max_range_size.#
# If you have more than about 500-600 states, the calculations will get REALLY slow,#
# since the program has to exponentiate a matrix of e.g. 600x600.  Often the computer#
# will just sit there and crunch, and never get through the calculation of the first#
# likelihood.#
# #
# (this is also what is usually happening when LAGRANGE hangs: you have too many states!)#
##
# To check the number of states for a given number of ranges, try:#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=FALSE)#
numstates_from_numareas(numareas=4, maxareas=3, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=2, include_null_range=TRUE)#
#
# Large numbers of areas have problems:#
numstates_from_numareas(numareas=10, maxareas=10, include_null_range=TRUE)#
#
# ...unless you limit the max_range_size:#
numstates_from_numareas(numareas=10, maxareas=2, include_null_range=TRUE)#
#####################################################
#####################################################
#
########################################################
########################################################
# DEC AND DEC+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DEC" model is identical with #
# the Lagrange DEC model, and should return identical#
# ML estimates of parameters, and the same #
# log-likelihoods, for the same datasets.#
##
# Ancestral state probabilities at nodes will be slightly #
# different, since BioGeoBEARS is reporting the #
# ancestral state probabilities under the global ML#
# model, and Lagrange is reporting ancestral state#
# probabilities after re-optimizing the likelihood#
# after fixing the state at each node. These will #
# be similar, but not identical. See Matzke (2014),#
# Systematic Biology, for discussion.#
##
# Also see Matzke (2014) for presentation of the #
# DEC+J model.#
########################################################
########################################################
#
########################################################
########################################################
#
########################################################
# Run DEC#
########################################################
#
# Intitialize a default model (DEC model)#
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
#
# Give BioGeoBEARS the location of the phylogeny Newick file#
BioGeoBEARS_run_object$trfn = trfn#
#
# Give BioGeoBEARS the location of the geography text file#
BioGeoBEARS_run_object$geogfn = geogfn#
#
# Input the maximum range size#
BioGeoBEARS_run_object$max_range_size = max_range_size#
#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; OMeara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
# 1. Here, un-comment ONLY the files you want to use.#
# 2. Also un-comment "BioGeoBEARS_run_object = section_the_tree(...", below.#
# 3. For example files see (a) extdata_dir, #
#  or (b) http://phylo.wikidot.com/biogeobears#files#
#  and BioGeoBEARS Google Group posts for further hints)#
##
# Uncomment files you wish to use in time-stratified analyses:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx();#
# if "GenSA", use Generalized Simulated Annealing, which seems better on high-dimensional#
# problems (5+ parameters), but seems to sometimes fail to optimize on simple problems#
BioGeoBEARS_run_object$num_cores_to_use = 1#
# (use more cores to speed it up; this requires#
# library(parallel) and/or library(snow). The package "parallel" #
# is now default on Macs in R 3.0+, but apparently still #
# has to be typed on some Windows machines. Note: apparently #
# parallel works on Mac command-line R, but not R.app.#
# BioGeoBEARS checks for this and resets to 1#
# core with R.app)#
#
# Sparse matrix exponentiation is an option for huge numbers of ranges/states (600+)#
# I have experimented with sparse matrix exponentiation in EXPOKIT/rexpokit,#
# but the results are imprecise and so I haven't explored it further.#
# In a Bayesian analysis, it might work OK, but the ML point estimates are#
# not identical.#
# Also, I have not implemented all functions to work with force_sparse=TRUE.#
# Volunteers are welcome to work on it!!#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC model#
# (nothing to do; defaults)#
#
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.#
BioGeoBEARS_run_object#
#
# This contains the model object#
BioGeoBEARS_run_object$BioGeoBEARS_model_object#
#
# This table contains the parameters of the model #
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table#
#
# Run this to check inputs. Read the error messages if you get them!#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# For a slow analysis, run once, then set runslow=FALSE to just #
# load the saved result.#
runslow = TRUE#
resfn = "apes_DEC_M0_unconstrained_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDEC = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDEC = res#
    }#
########################################################
# For comparison to PhyBEARS#
########################################################
res = resDEC#
names(res)#
#
resDEC$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS#
resDEC$ML_marginal_prob_each_state_at_branch_top_AT_node#
resDEC$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS#
#
mats = get_Qmat_COOmat_from_res(resDEC)#
Qmat = mats$Qmat#
#
u0 = resDEC$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[6,]#
result = u0 %*% expm(Qmat)#
#
result == resDEC$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS[6,]#
#
resDEC$ML_marginal_prob_each_state_at_branch_top_AT_node#
#
cft(resDEC$ML_marginal_prob_each_state_at_branch_bottom_below_node, digits=4)#
cft(resDEC$ML_marginal_prob_each_state_at_branch_top_AT_node, digits=4)#
#
paste0(c(resDEC$ML_marginal_prob_each_state_at_branch_bottom_below_node), collapse=", ")#
paste0(c(resDEC$ML_marginal_prob_each_state_at_branch_top_AT_node), collapse=", ")#
########################################################
# Run DEC+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; OMeara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx();#
# if "GenSA", use Generalized Simulated Annealing, which seems better on high-dimensional#
# problems (5+ parameters), but seems to sometimes fail to optimize on simple problems#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDEC$outputs@params_table["d","est"]#
estart = resDEC$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Add j as a free parameter#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "apes_DEC+J_M0_unconstrained_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDECj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDECj = res#
    }#
########################################################
# For comparison to PhyBEARS#
########################################################
res = resDECj#
names(res)#
#
resDECj$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS#
resDECj$ML_marginal_prob_each_state_at_branch_top_AT_node#
resDECj$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS#
#
mats = get_Qmat_COOmat_from_res(resDECj)#
Qmat = mats$Qmat#
#
u0 = resDECj$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[6,]#
result = u0 %*% expm(Qmat)#
#
result == resDECj$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS[6,]#
#
resDECj$ML_marginal_prob_each_state_at_branch_top_AT_node#
#
cft(resDECj$ML_marginal_prob_each_state_at_branch_bottom_below_node, digits=4)#
cft(resDECj$ML_marginal_prob_each_state_at_branch_top_AT_node, digits=4)#
cat(c(resDECj$ML_marginal_prob_each_state_at_branch_bottom_below_node), sep=", ")#
#
cat(c(resDECj$ML_marginal_prob_each_state_at_branch_top_AT_node), sep=", ")#
########################################################
# PDF plots#
########################################################
pdffn = "apes_DEC_vs_DEC+J_M0_unconstrained_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - DEC#
########################################################
analysis_titletxt ="BioGeoBEARS DEC on apes M0_unconstrained"#
#
# Setup#
results_object = resDEC#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - DECJ#
########################################################
analysis_titletxt ="BioGeoBEARS DEC+J on apes M0_unconstrained"#
#
# Setup#
results_object = resDECj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()  # Turn off PDF#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr) # Plot it#
#
########################################################
########################################################
# DIVALIKE AND DIVALIKE+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DIVALIKE" model is not identical with #
# Ronquist (1997)'s parsimony DIVA. It is a likelihood#
# interpretation of DIVA, constructed by modelling DIVA's#
# processes the way DEC does, but only allowing the #
# processes DIVA allows (widespread vicariance: yes; subset#
# sympatry: no; see Ronquist & Sanmartin 2011, Figure 4).#
##
# DIVALIKE is a likelihood interpretation of parsimony#
# DIVA, and it is "like DIVA" -- similar to, but not#
# identical to, parsimony DIVA.#
##
# I thus now call the model "DIVALIKE", and you should also. ;-)#
########################################################
########################################################
#
########################################################
# Run DIVALIKE#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; OMeara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx();#
# if "GenSA", use Generalized Simulated Annealing, which seems better on high-dimensional#
# problems (5+ parameters), but seems to sometimes fail to optimize on simple problems#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DIVALIKE model#
# Remove subset-sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "2-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "ysv*1/2"#
#
# Allow classic, widespread vicariance; all events equiprobable#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","init"] = 0.5#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","est"] = 0.5#
#
# No jump dispersal/founder-event speciation#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = 0.01#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = 0.01#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
runslow = TRUE#
resfn = "apes_DIVALIKE_M0_unconstrained_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDIVALIKE = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDIVALIKE = res#
    }#
########################################################
# For comparison to PhyBEARS#
########################################################
res = resDIVALIKE#
names(res)#
#
resDIVALIKE$total_loglikelihood#
resDIVALIKE$outputs@params_table["d","est"]#
resDIVALIKE$outputs@params_table["e","est"]#
resDIVALIKE$outputs@params_table["j","est"]#
resDIVALIKE$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS#
resDIVALIKE$ML_marginal_prob_each_state_at_branch_top_AT_node#
resDIVALIKE$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS#
#
mats = get_Qmat_COOmat_from_res(resDIVALIKE)#
Qmat = mats$Qmat#
#
u0 = resDIVALIKE$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[6,]#
result = u0 %*% expm(Qmat)#
#
result == resDIVALIKE$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS[6,]#
#
resDIVALIKE$ML_marginal_prob_each_state_at_branch_top_AT_node#
#
cft(resDIVALIKE$ML_marginal_prob_each_state_at_branch_bottom_below_node, digits=4)#
cft(resDIVALIKE$ML_marginal_prob_each_state_at_branch_top_AT_node, digits=4)#
cat(c(resDIVALIKE$ML_marginal_prob_each_state_at_branch_bottom_below_node), sep=", ")#
#
cat(c(resDIVALIKE$ML_marginal_prob_each_state_at_branch_top_AT_node), sep=", ")
########################################################
# Run BAYAREALIKE#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; OMeara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx();#
# if "GenSA", use Generalized Simulated Annealing, which seems better on high-dimensional#
# problems (5+ parameters), but seems to sometimes fail to optimize on simple problems#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up BAYAREALIKE model#
# No subset sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
# No vicariance#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","est"] = 0.0#
#
# No jump dispersal/founder-event speciation#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = 0.01#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = 0.01#
#
# Adjust linkage between parameters#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "1-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/1"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "1-j"#
#
# Only sympatric/range-copying (y) events allowed, and with #
# exact copying (both descendants always the same size as the ancestor)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","init"] = 0.9999#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","est"] = 0.9999#
#
# Check the inputs#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
runslow = TRUE#
resfn = "apes_BAYAREALIKE_M0_unconstrained_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resBAYAREALIKE = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resBAYAREALIKE = res#
    }#
#
########################################################
# For comparison to PhyBEARS#
########################################################
res = BAYAREALIKE#
names(res)#
#
resBAYAREALIKE$total_loglikelihood#
resBAYAREALIKE$outputs@params_table["d","est"]#
resBAYAREALIKE$outputs@params_table["e","est"]#
resBAYAREALIKE$outputs@params_table["j","est"]#
#
BAYAREALIKE$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS#
BAYAREALIKE$ML_marginal_prob_each_state_at_branch_top_AT_node#
BAYAREALIKE$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS#
#
mats = get_Qmat_COOmat_from_res(BAYAREALIKE)#
Qmat = mats$Qmat#
#
u0 = BAYAREALIKE$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[6,]#
result = u0 %*% expm(Qmat)#
#
result == BAYAREALIKE$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS[6,]#
#
BAYAREALIKE$ML_marginal_prob_each_state_at_branch_top_AT_node#
#
cft(BAYAREALIKE$ML_marginal_prob_each_state_at_branch_bottom_below_node, digits=4)#
cft(BAYAREALIKE$ML_marginal_prob_each_state_at_branch_top_AT_node, digits=4)#
cat(c(BAYAREALIKE$ML_marginal_prob_each_state_at_branch_bottom_below_node), sep=", ")#
#
cat(c(BAYAREALIKE$ML_marginal_prob_each_state_at_branch_top_AT_node), sep=", ")
'
'
res = BAYAREALIKE#
names(res)#
#
resBAYAREALIKE$total_loglikelihood#
resBAYAREALIKE$outputs@params_table["d","est"]#
resBAYAREALIKE$outputs@params_table["e","est"]#
resBAYAREALIKE$outputs@params_table["j","est"]#
#
resBAYAREALIKE$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS#
resBAYAREALIKE$ML_marginal_prob_each_state_at_branch_top_AT_node#
resBAYAREALIKE$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS#
#
mats = get_Qmat_COOmat_from_res(resBAYAREALIKE)#
Qmat = mats$Qmat#
#
u0 = resBAYAREALIKE$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[6,]#
result = u0 %*% expm(Qmat)#
#
result == resBAYAREALIKE$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS[6,]#
#
resBAYAREALIKE$ML_marginal_prob_each_state_at_branch_top_AT_node#
#
cft(resBAYAREALIKE$ML_marginal_prob_each_state_at_branch_bottom_below_node, digits=4)#
cft(resBAYAREALIKE$ML_marginal_prob_each_state_at_branch_top_AT_node, digits=4)#
cat(c(resBAYAREALIKE$ML_marginal_prob_each_state_at_branch_bottom_below_node), sep=", ")#
#
cat(c(resBAYAREALIKE$ML_marginal_prob_each_state_at_branch_top_AT_node), sep=", ")
resBAYAREALIKE$outputs
########################################################
# Run BAYAREALIKE+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; OMeara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up BAYAREALIKE+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resBAYAREALIKE$outputs@params_table["d","est"]#
estart = resBAYAREALIKE$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# No subset sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
# No vicariance#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","est"] = 0.0#
#
# *DO* allow jump dispersal/founder-event speciation (set the starting value close to 0)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
# Under BAYAREALIKE+J, the max of "j" should be 1, not 3 (as is default in DEC+J) or 2 (as in DIVALIKE+J)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 0.99999#
#
# Adjust linkage between parameters#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "1-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/1"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "1-j"#
#
# Only sympatric/range-copying (y) events allowed, and with #
# exact copying (both descendants always the same size as the ancestor)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","init"] = 0.9999#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","est"] = 0.9999#
#
# NOTE (NJM, 2014-04): BAYAREALIKE+J seems to crash on some computers, usually Windows #
# machines. I can't replicate this on my Mac machines, but it is almost certainly#
# just some precision under-run issue, when optim/optimx tries some parameter value #
# just below zero.  The "min" and "max" options on each parameter are supposed to#
# prevent this, but apparently optim/optimx sometimes go slightly beyond #
# these limits.  Anyway, if you get a crash, try raising "min" and lowering "max" #
# slightly for each parameter:#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","min"] = 0.0000001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","max"] = 4.9999999#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","min"] = 0.0000001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","max"] = 4.9999999#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","min"] = 0.00001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 0.99999#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "apes_BAYAREALIKE+J_M0_unconstrained_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resBAYAREALIKEj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resBAYAREALIKEj = res#
    }
resBAYAREALIKEj$total_loglikelihood
resBAYAREALIKE$total_loglikelihood
resBAYAREALIKE$output
resBAYAREALIKE
res = BAYAREALIKEj#
names(res)#
#
resBAYAREALIKEj$total_loglikelihood#
resBAYAREALIKEj$outputs@params_table["d","est"]#
resBAYAREALIKEj$outputs@params_table["e","est"]#
resBAYAREALIKEj$outputs@params_table["j","est"]#
#
resBAYAREALIKEj$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS#
resBAYAREALIKEj$ML_marginal_prob_each_state_at_branch_top_AT_node#
resBAYAREALIKEj$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS#
#
mats = get_Qmat_COOmat_from_res(resBAYAREALIKEj)#
Qmat = mats$Qmat#
#
u0 = resBAYAREALIKEj$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[6,]#
result = u0 %*% expm(Qmat)#
#
result == resBAYAREALIKEj$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS[6,]#
#
resBAYAREALIKEj$ML_marginal_prob_each_state_at_branch_top_AT_node#
#
cft(resBAYAREALIKEj$ML_marginal_prob_each_state_at_branch_bottom_below_node, digits=4)#
cft(resBAYAREALIKEj$ML_marginal_prob_each_state_at_branch_top_AT_node, digits=4)#
cat(c(resBAYAREALIKEj$ML_marginal_prob_each_state_at_branch_bottom_below_node), sep=", ")#
#
cat(c(resBAYAREALIKEj$ML_marginal_prob_each_state_at_branch_top_AT_node), sep=", ")
resDIVALIKEj
resDIVALIKEj$total_loglikelihood
res = resDIVALIKEj#
names(res)#
#
resDIVALIKEj$total_loglikelihood#
resDIVALIKEj$outputs@params_table["d","est"]#
resDIVALIKEj$outputs@params_table["e","est"]#
resDIVALIKEj$outputs@params_table["j","est"]#
resDIVALIKEj$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS#
resDIVALIKEj$ML_marginal_prob_each_state_at_branch_top_AT_node#
resDIVALIKEj$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS#
#
mats = get_Qmat_COOmat_from_res(resDIVALIKEj)#
Qmat = mats$Qmat#
#
u0 = resDIVALIKEj$relative_probs_of_each_state_at_branch_bottom_below_node_UPPASS[6,]#
result = u0 %*% expm(Qmat)#
#
result == resDIVALIKEj$relative_probs_of_each_state_at_branch_top_AT_node_UPPASS[6,]#
#
resDIVALIKEj$ML_marginal_prob_each_state_at_branch_top_AT_node#
#
cft(resDIVALIKEj$ML_marginal_prob_each_state_at_branch_bottom_below_node, digits=4)#
cft(resDIVALIKEj$ML_marginal_prob_each_state_at_branch_top_AT_node, digits=4)#
cat(c(resDIVALIKEj$ML_marginal_prob_each_state_at_branch_bottom_below_node), sep=", ")#
#
cat(c(resDIVALIKEj$ML_marginal_prob_each_state_at_branch_top_AT_node), sep=", ")
